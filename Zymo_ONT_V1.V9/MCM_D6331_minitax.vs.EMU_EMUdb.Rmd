---
title: "Zymo D6331 : EMU vs minitax on EMU database"
author: "Balázs Kakuk"
date: "2024-10-20"
output: html_document
---

```{css, echo=FALSE}
    body .main-container {
      max-width: 90% !important;
      width: 90% !important;
    }
    body {
      max-width: 90% !important;
      margin-left: auto;
      margin-right: auto;
    }
```


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = F, fig.align = 'center', fig.height = 10, fig.width = 30, warning = F, message = F, error = F)
library(tidyverse)
library(ggpubr)
library(factoextra)
library(FactoMineR)
library(ggrepel)
library(phyloseq, quietly = T)
library(DESeq2)
library(data.table)
library(ggsci)
library(hrbrthemes)
library(ggh4x)
library(RColorBrewer)
library(stringr); library(stringi)
library("ape")
library("ggtree")
library(Biostrings)
library(dplyr)
library(UpSetR)
library(ComplexHeatmap)
library(genefilter)
library(viridis)

## Own functions
misc.dir    <- 'C:/my.R.packages/Rlyeh-main/R'
minitax.dir <- 'C:/my.R.packages/minitax/R'

if (.Platform$OS.type!="windows") {
  
  misc.dir  <- paste0('/mnt/', gsub(':', '/', tolower(gsub('/.*', '', misc.dir))),
                      stri_replace_first_regex(misc.dir, '.*:\\/', '')
  )
  
  minitax.dir  <- paste0('/mnt/', gsub(':', '/', tolower(gsub('/.*', '', minitax.dir))),
                         stri_replace_first_regex(minitax.dir, '.*:\\/', '')
  )
  
}

for(f in list.files(misc.dir,    '*.R', full.names = T)) { try({message(f); source(f)}) }
for(f in list.files(minitax.dir, '*.R', full.names = T)) { try({message(f); source(f)}) }

bam.flags           <- fread(paste0(misc.dir, '/bam.flags.tsv'))
gff_compare_classes <- fread(paste0(misc.dir, '/gff_compare.txt'))
nproc <- 32


### General settings

filt.version <- ''
filtering    <- ''
writetables  <- T
save.Figs    <- F
res.dir      <- 'MCM_D6331_minitax.vs.EMU_EMUdb'; dir.create(res.dir)
#platforms <- c('illumina', 'PacBIO')

## color palette
alpha   <- 0.9
pal.man <- c(brewer.pal(7, 'Set1'), brewer.pal(8, 'Accent')[c(1,2,6)], brewer.pal(8, 'Set2')[c(1,3,5,6,7)], brewer.pal(8, 'Dark2') )
pal.man <- c(colorvec[c(8,32,12:14,17,24,1:2,4,7,5,6,3,10,11,27:28,9,29)], 'grey', 'black')
pal.man <- alpha(c(pal.man, pal.man), alpha)

## taxonomic ranks
ranks <- c("superkingdom", "phylum", "class", "order", "family", "genus", "species")

### minitax settings
## Database
db <- 'EMUdb'
db.dir <- 'C:/data/databases/EMU'
## Genome Size normalization?
NormToGenomeSize <- F
NormFunction     <- 'mean'
## MAPQ filtering ?
mapq.filt <- NA #  1:59 # 
## Filtering samples
filter.samples.pattern <- 'LCA|Undetermined|SpeciesEstimate|BestAln'  ### filter out LCA method


## Exclude unclassified reads?
exclude.unclass <- T

## Omit very low abundance samples
abund.threshold <- 10

## Other settings
consider.euk <- F
count_multiplier <- 100000
count_colname    <- c('16S Only', 'Gram Stain')


### Gold Standard Settings
cami.lineage <- 'db'
add.GS.taxa <- F ## add all GS taxa to the barplots and the correlation plots?
zymo.GS <- read_delim('C:/data/databases/zymo/zymo_6331_composition.txt')
GS_name <- 'Zymo_6331'
GS_nr   <- 1
GS_version <- 'D6331'
just_GS <- T
vars <- c('platform', 'primer') # 'GS_name' ('project') # c('DNA_isolation_method', 'db', 'workflow', 'method', 
#vars <- c('Vregion', 'platform', 'db', 'workflow', 'method','DNA_isolation_method') # 'GS_version'
glom_spec <- T


## Exclude Bifidobacteria?
exclude.Bifido <- F
if(exclude.Bifido) {
  zymo.GS <- zymo.GS[!grepl('Bifodobac', zymo.GS[,1]) & !grepl('Bifodobac', zymo.GS[,2]), ]
}

## Keep and plot GS taxa only?
keep.GS.taxa.only <- F

mark.GS.Taxa      <- T
merge.non.GS.Taxa <- F


## calculate correlation from top20 or from all taxa?
correl <- 'topN'

## Fix taxa
crop_taxa <- NULL # 'Veillonella rogosae|Prevotella corporis'

genera_to_glom <- data.frame(glom= c('Veillonella', 'Faecalibacterium', 'Prevotella', 'Roseburia'),
                           to  = c('Veillonella rogosae','Faecalibacterium prausnitzii', 'Prevotella corporis', 'Roseburia hominis')) ## NULL
species_to_glom <- data.frame(glom= c('Bacteroides fragilis', 'Bacteroides fragilis CAG:47', 'Bacteroides fragilis_A'),
                           to  = c('Bacteroides fragilis')) ## NULL



abundance_threshold <- 1
filter_func <- filterfun(function(x) sum(x) > abundance_threshold)

```



# Notes

- Unclassified reads *were* excluded
- Taxa with total reads number of 10 or lower were excluded 
- Eukaryotes *were* excluded from the analyis

```{r, Database import}
# altough *Lactobacillus fermentum* was changed to *Limosilactobacillus fermentum* 
  
#### Database import ####

if (db == 'proGcontigs_2') {
  prog.db <- fread(paste0(db.dir, '/proGenomes2.1_specI_lineageNCBI.tab'), header = F)
  colnames(prog.db) <- c("genome", "superkingdom", "phylum", "class", "order", "family", "genus", "species")
  prog.db <- data.frame(taxid=gsub('\\..*', '', prog.db$genome  ), prog.db)
  ranks <- c("superkingdom", "phylum", "class", "order", "family", "genus", "species")
  prog.db$taxid <- as.integer(prog.db$taxid)
  
  prog.db[,ranks]  <- as.data.frame(apply(prog.db[,ranks], 2, function(x) str_replace(as.character(unlist(x)),  pattern = "^\\d+\\s", replacement = "")))
  
  prog.gt <- gather(prog.db, rank, taxon, -c(1:2))
  prog.db.spec.uni <- unique.data.frame(prog.db[,ranks])
  
  db.data <- prog.db
  db.name <- db
  
  prog.db.uni     <- db.data %>% distinct(across(all_of(c('taxid', ranks)))) #unique.data.frame(db.data[,c('taxid', ranks)])
  db.uni.data     <- prog.db.uni

   if (NormToGenomeSize) {
    genome_sizes <- as.data.frame(fread(paste0(db.dir, '/proGenomes2.1_specI_lineageNCBI.genomesize.tab')))
    genome_sizes[genome_sizes == ''] <- NA
    genome_sizes[,ranks]  <- 
      as.data.frame(apply(genome_sizes[,ranks], 2, 
                          function(x) str_replace(as.character(unlist(x)),  pattern = "^\\d+\\s", replacement = "")))
  }
  
  db.uni.ranks <- unique.data.frame(db.uni.data[,ranks])
  
  #### Fix Lactobacillus in proGenomes_2
  db.uni.ranks$genus  [db.uni.ranks$species ==  'Lactobacillus fermentum' ] <- 'Limosilactobacillus'
  db.uni.ranks$species[db.uni.ranks$species ==  'Lactobacillus fermentum' ] <- 'Limosilactobacillus fermentum'

} else if (db=="all_NCBI_genomes") {
  
  #db.data     <- fread(paste0(db.dir, "/NCBI.db.tsv"), header = T)
  db.uni.data <- fread(paste0(db.dir, "/NCBI.db.uni.tsv"), header = T)
  db.uni.data <- unique(db.uni.data[,..ranks])
  db.uni.data[db.uni.data == ''] <- NA

  if (NormToGenomeSize) {
    genome_sizes <- as.data.frame(fread(paste0(db.dir, '/NCBI.db.genomesize.tsv')))
    genome_sizes[genome_sizes == ''] <- NA
  }
  
  
  #### Fix Akkermansia municiphila
  db.uni.data <- data.table(plyr::rbind.fill(db.uni.data,
    setNames(data.frame(
      rbind(c('Bacteria', 'Verrucomicrobia', 'Verrucomicrobiae', 'Verrucomicrobiales', 'Akkermansiaceae', 'Akkermansia', 'Akkermansia muciniphila'))),
             ranks)
  ))
} else if (db == 'EMUdb') {

  ranks <- c("superkingdom", "phylum", "class", "order", "family", "genus", "species")
  emu.db    <- read.delim(paste0(db.dir, '/taxonomy.tsv'))
  colnames(emu.db)[1] <- 'taxid'
  emu.db <- emu.db[,c('taxid', ranks)]
  emu.db[emu.db == ''] <- NA

  emu.fasta <- seqinr::read.fasta(paste0(db.dir, '/species_taxid.fasta'), whole.header = T)
  emu.fasta <- data.frame(names=names(emu.fasta), taxid=gsub(':.*', '', names(emu.fasta)))
  emu.fasta$seq_id <- gsub(' \\[.*', '', emu.fasta$names)

  emu.idx    <- merge(emu.fasta, emu.db, by='taxid')

  db.data <- data.table(emu.db)
  db.name <- db #'EMUdb'
  db.uni.data <- db.data

}


```


## Import Emu data
```{r}
#### Import EMU

ps.all <- readRDS("EMU/ps/unfiltered/primer.exp.all.PS.rds")

## correct metadata
ps.all@sam_data$platform <- 'ONT'
ps.all@sam_data$workflow <- 'EMU'
ps.all@sam_data$db       <- 'EMUdb'
ps.all@sam_data$Vregion  <- 'V1_V9'
ps.all@sam_data$method   <- 'EMU'

##
ps.all@sam_data$sample <- sample_names(ps.all)  

metadata <- data.frame(sample_data(ps.all))
otutab   <- data.frame(otu_table(ps.all))
taxtab   <- data.frame(tax_table(ps.all))

## add tax.identity -->> species in EMU
setDT(taxtab)
taxtab[,tax.identity := species]
taxtab[,lineage      := paste(superkingdom, phylum, class, order, family, genus, species, sep='::')]
setDF(taxtab)

rownames(taxtab) <- taxtab$lineage
rownames(otutab) <- taxtab$lineage

ps.all <- phyloseq(tax_table(as.matrix(taxtab)),
                   otu_table(as.matrix(otutab), taxa_are_rows = T),
                   sample_data(metadata))

ps.emu <- ps.all

colSums(otutab)

```


## Import minitax data
```{r}
#### minitax
ps.mt.bestaln <- readRDS("minitax_NA_V1_V9_EMU_EMUdb/minitax_NA_ONT_V1_V9_EMUdb_BestAln_PS.rds")

ps.mt.randaln <- readRDS("minitax_NA_V1_V9_EMU_EMUdb/minitax_NA_ONT_V1_V9_EMUdb_RandAln_PS.rds")

ps.mt.lca     <- readRDS("minitax_NA_V1_V9_EMU_EMUdb/minitax_NA_ONT_V1_V9_EMUdb_LCA_PS.rds")

ps.mt.specest <- readRDS("minitax_NA_V1_V9_EMU_EMUdb/minitax_NA_ONT_V1_V9_EMUdb_SpeciesEstimate_PS.rds")


ps.mt <- merge_phyloseq(ps.mt.bestaln,
                        ps.mt.randaln,
                        ps.mt.lca,
                        ps.mt.specest)

ps.mt@sam_data$sample    <- gsub('_pass', '', ps.mt@sam_data$sample)
sample_names(ps.mt)      <- gsub('_pass', '', sample_names(ps.mt))
ps.mt@sam_data$sample_ID <- sample_names(ps.mt)

meta.mt <- data.table(data.frame(ps.mt@sam_data))#, keep.rownames = 'sampleID')


otutab.mt   <- data.frame(otu_table(ps.mt))
taxtab.mt   <- data.frame(tax_table(ps.mt))

```

## Fix minitax metadata
```{r}
setDT(metadata)
meta.all <- merge(meta.mt, metadata[,.(sample, name, source, barcode, primer)], by='sample')
setDF(meta.all)
rownames(meta.all) <- meta.all$sample_ID

meta.all <- meta.all[sample_names(ps.mt),]

ps.mt@sam_data <- sample_data(meta.all)
```


```{r, eval=FALSE}
## Glomerating on sepcies level for check
ps.mt <- tax_glom_fast(ps.mt, rank_level =  7, ignore_lineage = T)

otutab   <- data.frame(otu_table(ps.mt))
taxtab   <- data.frame(tax_table(ps.mt))

```


## Merge Emu and minitax
```{r}
ps.all <- merge_phyloseq(ps.emu, ps.mt)  

meta.all <- data.frame(ps.all@sam_data)

metadata <- data.table(meta.all)

otutab   <- data.frame(otu_table(ps.all))
taxtab   <- data.frame(tax_table(ps.all))

```



## Fix metadata
```{r}
setDT(metadata)
metadata[,group        := .GRP, by=.(source, primer, Vregion, platform, workflow, method, db)] 
metadata[,sample_nr    := seq_along(sample), by=.(group)]
metadata[,sample_name  := paste0(primer, sample_nr)]

metadata[,sample       := paste(source, primer, Vregion, platform, workflow, method, db, sample_nr, sep='_')] 

metadata <- data.frame(metadata, row.names = metadata$sample)



sample_names(ps.all) <- metadata$sample
ps.all@sam_data <- sample_data(metadata)


```



## Filter Exp data
```{r}
## Filter for samples
samples.to.keep <- c(
  sample_names(ps.all)[
    grepl('GMS',   metadata$source)]
)

ps.all <- prune_samples(samples.to.keep, ps.all)

##
ps.all@sam_data$sample <- sample_names(ps.all)  



## Filter out taxa that no longer have an abundance
abundance_threshold <- 1
filter_func <- filterfun(function(x) sum(x) > abundance_threshold)
ps.all <- filter_taxa(ps.all, filter_func, prune = TRUE)

metadata <- data.frame(sample_data(ps.all))
otutab   <- data.frame(otu_table(ps.all))
taxtab   <- data.frame(tax_table(ps.all))

```


## Filter samples based on total read count
```{r}
samples.to.keep <- colnames(
  as.data.frame(otutab[,colSums(otutab) >= abund.threshold])
  )

message("The following samples were filtered out, because they had a read count less than ", abund.threshold, ": \n", 
        paste0(setdiff(sample_names(ps.all),  samples.to.keep), collapse = '\n'))

ps.all <- prune_samples(samples.to.keep, ps.all)

abundance_threshold <- 1
filter_func <- filterfun(function(x) sum(x) > abundance_threshold)
ps.all <- filter_taxa(ps.all, filter_func, prune = TRUE)


metadata <- data.frame(sample_data(ps.all))
otutab   <- data.frame(otu_table(ps.all))
taxtab   <- data.frame(tax_table(ps.all))


```



## Add lineage and metadata to Gold Standard Data

*Limosilactobacillus fermentum* in the theoretical composition was changed to *Lactobacillus fermentum*
```{r, Import Theoretical Composition, eval=T}
###
#zymo.GS[,count_colname] <- as.numeric(zymo.GS[,count_colname])

colnames(zymo.GS)[1] <- 'species'
zymo.GS <- zymo.GS[,c('species', count_colname)]
colnames(zymo.GS)[2] <- 'count'

zymo.GS <- zymo.GS[zymo.GS$count > 0, ]

zymo.GS$count <- zymo.GS$count * count_multiplier

## summarise on species-level (mainly because of Eschericia strains)
if(glom_spec) {
  setDT(zymo.GS)
  zymo.GS$strain  <- zymo.GS$species
  zymo.GS$species <- gsub(' \\(.*', '', zymo.GS$species)
  cols_by         <- c('species') 
  zymo.GS[,count := sum(count), by=cols_by]
  zymo.GS[,strain := NULL]
  zymo.GS <- unique(zymo.GS)
}


if(!is.null(crop_taxa)) {
  zymo.GS <- zymo.GS[grep(crop_taxa, zymo.GS$species, invert = T),]
}

zymo.GS <- as.data.frame(merge(db.uni.data,  zymo.GS, by='species', all.y=T))
if(!consider.euk) { ## will be done later
  zymo.GS <- zymo.GS[
    #zymo.GS$superkingdom != 'Eukaryota'
    #grep('Saccharomyces|Candida|Cryptococcus', zymo.GS$species, invert = T)
    ,]
}

mtgs <- unique.data.frame(as.data.frame(metadata[,vars])); colnames(mtgs) <- vars
mtgs$sample_name <- GS_name
mtgs <- unite(mtgs, 'sample', c('sample_name', vars), remove = F)
rownames(mtgs) <- mtgs$sample

taxtab.gs <- zymo.GS[,ranks]
rownames(taxtab.gs) <- taxtab.gs[,'species']

otutab.gs <- setNames(data.frame(replicate(length(mtgs$sample), zymo.GS$count, simplify = FALSE), row.names = rownames(taxtab.gs)), mtgs$sample)

mtgs$GS_name   <- GS_name
mtgs$sample_nr <- GS_name

#mtgs <- merge(metadata.gs, mtgs, by=c(0,1,2,3))[,-1]
#rownames(mtgs) <- mtgs$sample


ps.gs <- phyloseq(otu_table(as.matrix(otutab.gs), taxa_are_rows = T), 
                   tax_table(as.matrix(taxtab.gs)), 
                   sample_data(mtgs))
```


```{r, Merge Theoretical Compositions}

ps.gsa <- ps.gs

```


```{r}
### Add Gold Standard version to all sample names
sample_names(ps.all) <- paste0(sample_names(ps.all), '_', GS_version)
ps.all@sam_data$GS_version <- GS_version

### Fix sample names
ps.all@sam_data$sample <- sample_names(ps.all)

```



```{r, NA to unclassified}

#taxtab[is.na(taxtab)] <- 'unclassified'

#ps.all   <- phyloseq(otu_table(as.matrix(otutab), taxa_are_rows = T),
#                     tax_table(as.matrix(taxtab)),
#                     sample_data(metadata))

ps.all@tax_table[is.na(ps.all@tax_table)] <- 'unassigned'

otutab   <- data.frame(otu_table  (ps.all))
taxtab   <- data.frame(tax_table  (ps.all))
metadata <- data.frame(sample_data(ps.all))
```



```{r, Exclude unclassified reads}

if (exclude.unclass) {
  
  snames <- sample_names(ps.all)
  
  otutab <- otutab[rownames(otutab) != 'unassigned', ]
  taxtab <- taxtab[rownames(taxtab) != 'unassigned', ]
  
  otutab <- otutab[taxtab$species   != 'unassigned', ]
  taxtab <- taxtab[taxtab$species   != 'unassigned', ]
  
  otutab <- otutab[taxtab$phylum    != 'unassigned', ]
  taxtab <- taxtab[taxtab$phylum    != 'unassigned', ]
  
  colnames(otutab) <- snames
  
  ps.all   <- phyloseq(otu_table(as.matrix(otutab), taxa_are_rows = T),
                       tax_table(as.matrix(taxtab)),
                       sample_data(metadata))

}

metadata <- data.frame(sample_data(ps.all))
```


```{r}
## Filter for taxa below threshold, again ?
if (!is.na(abund.threshold)) {

  snames <- sample_names(ps.all)
  
  otutab   <- data.frame(otu_table(ps.all))
  taxtab   <- data.frame(tax_table(ps.all))
  metadata <- data.frame(sample_data(ps.all))

  otutab  <- otutab[rowSums(otutab) >= abund.threshold, ]
  taxtab  <- taxtab[rowSums(otutab) >= abund.threshold, ]

  colnames(otutab) <- snames
  
  ps.all   <- phyloseq(otu_table(as.matrix(otutab), taxa_are_rows = T),
                       tax_table(as.matrix(taxtab)),
                       sample_data(metadata))


}

```


```{r, eval=F}
### Check if species names are unique
if( n_distinct(ps.all@tax_table[,'species']) == nrow(ps.all@tax_table[,]) ) {
  
  message('using species as taxon identifier')
  
  ### And get rid of tax.identity AND lineage from taxtab if so  
  
  ps <- ps.all
  
  metadata   <- data.frame(sample_data(ps))
  otutab     <- data.frame(otu_table(ps))
  taxtab     <- data.frame(tax_table(ps))
  samp_names <- sample_names(ps)

  rownames(taxtab) <- taxtab$species
  rownames(otutab) <- rownames(taxtab)
  
  taxtab           <- taxtab[,ranks]  
  
  colnames(otutab) <- samp_names
  
  ps <- phyloseq(tax_table(as.matrix(taxtab)),
                 otu_table(as.matrix(otutab), taxa_are_rows = T),
                 sample_data(metadata))
  
  ps.all <- ps
 
} else {
  
  ### Otherwise get rid of tax.identity OR lineage from taxtab if so
  
  
  rank_names(ps.all)
  
  ps <- ps.all
  
  metadata   <- data.frame(sample_data(ps))
  otutab     <- data.frame(otu_table(ps))
  taxtab     <- data.frame(tax_table(ps))
  samp_names <- sample_names(ps)
  colnames(otutab)   <- samp_names
  rownames(metadata) <- samp_names
  
  taxtabuni <- unique.data.frame(taxtab[,c(ranks, 'tax.identity')]) 
  stopifnot(nrow(taxtabuni) == nrow(taxtab))
  dups <- dup(taxtabuni$tax.identity)
  if(length(dups) == 0) {
    message('using tax.identity as taxon identifier')
    rownames(taxtabuni) <- taxtabuni$tax.identity  
  } else {
    message('using lineage as taxon identifier')
    #rownames(taxtabuni) <- taxtabuni$tax.identity  
  }
  
  taxtabuni <- unique.data.frame(taxtabuni[,c(ranks)])
  stopifnot(nrow(taxtabuni) == nrow(taxtab))
  
  rownames(otutab) <- rownames(taxtabuni)
  
  ps <- phyloseq(tax_table(as.matrix(taxtabuni)),
                 otu_table(as.matrix(otutab), taxa_are_rows = T),
                 sample_data(metadata))
  
  
  ## Glomerating on sepcies level for check
  ps.glom <- tax_glom_fast(ps, rank_level =  7, ignore_lineage = T)
  
  
  ##
  metadata   <- data.frame(sample_data(ps))
  otutab     <- data.frame(otu_table(ps))
  taxtab     <- data.frame(tax_table(ps))
  samp_names <- sample_names(ps)
  colnames(otutab)   <- samp_names
  rownames(metadata) <- samp_names

}




```

```{r, Fix genera}


if(!is.null(genera_to_glom)) {
    
  taxatofilt <- taxa_names(ps.all)[!grepl(paste0(genera_to_glom$glom, collapse='|'), taxtab$genus)]

  ps <- prune_taxa(taxatofilt, ps.all)

  for (i in 1:nrow(genera_to_glom)) {
   
    glom   <- genera_to_glom[i, 'glom']
    to     <- genera_to_glom[i, 'to']
    
    message('Glomerating all hits from: ', glom, ' to: ', to)
    
    taxatokeep <- taxa_names(ps.all)[grepl(glom, taxtab$genus)]
    
    try({
    ## Glomerate several taxa from the same genus
    ps.glom     <- prune_taxa(taxatokeep, ps.all)
    ps.glom     <- tax_glom_fast(ps.glom, rank_level = 6, ignore_lineage = F)
    taxtab.glom <- data.frame(tax_table(ps.glom))
    
    ## Change the species name of these to the desired
    taxtab.glom$species <- to
    ps.glom@tax_table <- tax_table(as.matrix(taxtab.glom))
    taxa_names(ps.glom) <- to
    taxtab.glom <- data.frame(tax_table(ps.glom))
    
    ##
    ps <- merge_phyloseq(ps.glom, ps)
    
    })
    
  }
  
  ps.all <- ps
  
}

otutab   <- data.frame(otu_table(ps))
taxtab   <- data.frame(tax_table(ps))
metadata <- data.frame(sample_data(ps))
##

```


```{r, Fix species}

if(!is.null(species_to_glom)) {
  taxtab <- data.frame(tax_table(ps.all))
  for (i in 1:nrow(species_to_glom)) {
   
    glom <- species_to_glom$glom[i]
    to   <- species_to_glom$to[i]
    message('Glomerating all hits from: ', paste(glom, collapse = ' ,'), ' to: ', to)
    
    taxtab[rownames(taxtab) == glom, 'species'] <- to
  }
  ps.all@tax_table <- tax_table(as.matrix(taxtab))
  taxtab <- data.frame(tax_table(ps.all))
}

##

```
## Fix sample names from '-'
```{r}

sample_names(ps.all) <- gsub('-', '.', sample_names(ps.all))

```



## Merge exp data with GS
```{r}
metadata.gs <- data.frame(sample_data(ps.gsa))

## this caused non-sensical metadata changes
ps.all   <- merge_phyloseq(ps.gsa, ps.all)

## use own function to merge
#ps.all <- merge_phylo_fast(ps1 = ps.gsa, ps2 = ps.standard)

###
metadata <- data.frame(sample_data(ps.all))
otutab   <- data.frame(otu_table(ps.all))
taxtab   <- data.frame(tax_table(ps.all))
```



## Filter Taxa for Gold Standard

These are the taxa that were found in the experimental data
```{r, Gold Standard and Experimental Matches}
otutab.gsa     <- data.frame(otu_table(ps.gsa))
taxtab.gsa     <- data.frame(tax_table(ps.gsa))
metadata.gsa   <- data.frame(sample_data(ps.gsa))

otutab.sum     <- data.frame(EXP_sum=rowSums(otutab), row.names = rownames(otutab))

gs.exp.match   <- merge(zymo.GS, otutab.sum, all.x=T, by.x='species', by.y=0)

print(gs.exp.match)
```


```{r, keep taxa from Gold Standard}

taxa.gs        <- taxa_names(ps.gsa)
ps.standard    <- prune_taxa(taxa.gs, ps.all)

abundance_threshold <- abund.threshold
filter_func  <- filterfun(function(x) sum(x) > abundance_threshold)
   
ps.standard  <- filter_taxa(ps.standard, filter_func, prune = TRUE)


if (keep.GS.taxa.only) {

  ps.all <- ps.standard
  
} else {
  
  ps.all  <- filter_taxa(ps.all, filter_func, prune = TRUE) 
  
}


taxtab   <- data.frame(tax_table(ps.all))
otutab   <- data.frame(otu_table(ps.all))
metadata <- data.frame(sample_data(ps.all))

```


## Add Gram Stain Info
```{r, eval=T}
phyla.gram <- read.delim('C:/data/Gemini/Toti_all_comp_top20_phylum_ratios_Gram.tsv')[,1:2]
colnames(phyla.gram)[2] <- 'Gram.Stain'

taxtab   <- data.frame(tax_table(ps.all))
otutab   <- data.frame(otu_table(ps.all))
metadata <- data.frame(sample_data(ps.all))

rownames <- rownames(taxtab)
taxtab$rownames <- rownames

stopifnot(all.equal(taxa_names(ps.all), rownames))

taxtab.gram <- merge(taxtab, phyla.gram, by='phylum', all.x=T)

taxtab      <- data.frame(taxtab.gram[,c(ranks, 'Gram.Stain')], row.names = taxtab.gram$rownames)

taxtab      <- taxtab[rownames,]
otutab      <- otutab[rownames,]

ps.all <- phyloseq(tax_table(as.matrix(taxtab)),
                   otu_table(as.matrix(otutab), taxa_are_rows = T),
                   sample_data(metadata))


taxtab   <- data.frame(tax_table(ps.all))
otutab   <- data.frame(otu_table(ps.all))
metadata <- data.frame(sample_data(ps.all))


```



## Omit Eukaryotes
```{r, Omit Eukaryotes?}

if(!consider.euk) {
  taxtab      <- data.frame(tax_table(ps.all))
  taxatoprune <- rownames(taxtab)[!is.element(taxtab$superkingdom, 'Eukaryota') & !is.na(taxtab$superkingdom)]
  ps.all      <- prune_taxa(taxatoprune, ps.all)
  
}

otutab   <- data.frame(otu_table(ps.all))
taxtab   <- data.frame(tax_table(ps.all))
metadata <- data.frame(sample_data(ps.all))

```



#  Zymo D6300 : Relative abundance of taxa at each taxonomic level

```{r}

ps <- ps.all

```



```{r, Barplots}
scales <- 'fixed'
fig.height  <- 12
fig.width   <- 16
top <- 20
top.MCM <- 20

multiV <- c(F, T)

fig.height.vr <- fig.height
fig.width.vr  <- fig.width

## plotting function for barplots
plotfun <- function(ps, x='sample_nr', t=t, fill=t) {
  plot_bar(ps, x=x, fill=fill
         ) + 
    scale_fill_manual(values=as.character(pal.man)) +
    guides(fill = guide_legend(direction = "vertical", ncol = 1)) +
    theme_ipsum() + 
    theme(legend.position="right", 
          legend.text = element_text(face = "italic"),
          panel.spacing.x = unit(1.5, 'mm'),
          axis.text.x = element_text(),
          axis.title.x = element_blank()) +
    # facet_grid(rows = vars(sequencing_date), cols = vars(DNA_isolation_method), scales = 'free')
    facet_nested(rows = vars(primer), cols = vars(method), scales = 'free_x') # cols = vars(method)
}

```

## Gram Stain level

```{r, Glom taxa at Gram-level}
n <- 8

t <- rank_names(ps)[n]

## glomerate at n taxonomic level, regardless of lineage
ps.glom <- tax_glom_fast(ps, rank_level = n, ignore_lineage = T)
otutab <- data.frame(ps.glom@otu_table)

## normalize PS object per taxon sums
ps.glom.norm       <- norm.ps(ps.glom, 'sum')
#ps.glom.norm@otu_table

## top20 taxa from the glomerated at specific tax level
top.taxa           <- names(sort(taxa_sums(ps.glom.norm), decreasing=TRUE))[1:top]

## add all Gold standard taxa?
if (add.GS.taxa) {
  try({ top.taxa  <- unique(c(top.taxa, taxtab.gs[,t])) })
}

## prune normalized taxa
ps.glom.norm.top   <- prune_taxa(top.taxa, ps.glom.norm)
## prune taxa
ps.glom.top        <- prune_taxa(top.taxa, ps.glom)

## normalize PS object per taxon sums
ps.glom.norm       <- norm.ps(ps.glom, 'sum')

## top20 taxa from the glomerated at specific tax level
top.taxa           <- names(sort(taxa_sums(ps.glom.norm), decreasing=TRUE))[1:top]

## add all Gold standard taxa?
if (add.GS.taxa) {
  try({ top.taxa  <- unique(c(top.taxa, taxtab.gs[,t])) })
}

## prune normalized taxa
ps.glom.norm.top   <- prune_taxa(top.taxa, ps.glom.norm)
## prune taxa
ps.glom.top        <- prune_taxa(top.taxa, ps.glom)

## get data
ps.data.glom.top  <- df.from.ps(ps.glom.top,   comb=F)
ps.data.glom      <- df.from.ps(ps.glom,       comb=F)

## filenames for plots and tables
filenames <- c(
  paste0(res.dir, '_top' , top, '_', t, '_ratios'),
  paste0(res.dir, '_all_', t,           '_ratios') 
)
## write tables
if (writetables){
 write_tsv(ps.data.glom.top, paste0(res.dir, '/', filenames[1], '.tsv')) 
 write_tsv(ps.data.glom,     paste0(res.dir, '/', filenames[2], '.tsv')) 
}

```


```{r, Gram-level plot, fig.height=fig.height.vr, fig.width = fig.width.vr, eval=multiV[2]}

ggtop20    <- plotfun(
  ps.glom.norm.top,
                t=t, fill=t) + 
  theme(legend.position = 'right') +
  ggtitle(paste0('Top', top, ' ', t))

ggtop20

if (save.Figs){
  ggsave(paste0(res.dir, '/', filenames[1], '_Vregions.jpg'), width = fig.width.vr, height = fig.height.vr)
}



ps.glom.norm.top.gram <- ps.glom.norm.top
ps.glom.norm.gram     <- ps.glom.norm
ps.glom.top.gram      <- ps.glom.top
ps.glom.gram          <- ps.glom


```



## Phylum level

```{r, Glom taxa at Phylum-level}
n <- 2

t <- rank_names(ps)[n]

## glomerate at n taxonomic level, regardless of lineage
ps.glom <- tax_glom_fast(ps, rank_level = n, ignore_lineage = T)
otutab <- data.frame(ps.glom@otu_table)

## normalize PS object per taxon sums
ps.glom.norm       <- norm.ps(ps.glom, 'sum')
#ps.glom.norm@otu_table

## top20 taxa from the glomerated at specific tax level
top.taxa           <- names(sort(taxa_sums(ps.glom.norm), decreasing=TRUE))[1:top]

## add all Gold standard taxa?
if (add.GS.taxa) {
  top.taxa  <- unique(c(top.taxa, taxtab.gs[,t]))
}

## prune normalized taxa
ps.glom.norm.top   <- prune_taxa(top.taxa, ps.glom.norm)
## prune taxa
ps.glom.top        <- prune_taxa(top.taxa, ps.glom)

## normalize PS object per taxon sums
ps.glom.norm       <- norm.ps(ps.glom, 'sum')

## top20 taxa from the glomerated at specific tax level
top.taxa           <- names(sort(taxa_sums(ps.glom.norm), decreasing=TRUE))[1:top]

## add all Gold standard taxa?
if (add.GS.taxa) {
  top.taxa  <- unique(c(top.taxa, taxtab.gs[,t]))
}

## prune normalized taxa
ps.glom.norm.top   <- prune_taxa(top.taxa, ps.glom.norm)
## prune taxa
ps.glom.top        <- prune_taxa(top.taxa, ps.glom)

## get data
ps.data.glom.top  <- df.from.ps(ps.glom.top,   comb=F)
ps.data.glom      <- df.from.ps(ps.glom,       comb=F)

## filenames for plots and tables
filenames <- c(
  paste0(res.dir, '_top' , top, '_', t, '_ratios'),
  paste0(res.dir, '_all_', t,           '_ratios') 
)
## write tables
if (writetables){
 write_tsv(ps.data.glom.top, paste0(res.dir, '/', filenames[1], '.tsv')) 
 write_tsv(ps.data.glom,     paste0(res.dir, '/', filenames[2], '.tsv')) 
}

```

```{r}

## Mark GS Taxa with Asterisks
if (mark.GS.Taxa) {
  ps.glom.norm.top@tax_table[,t][ps.glom.norm.top@tax_table[,t] %in% taxtab.gs[,t]] <- paste0(ps.glom.norm.top@tax_table[,t][ps.glom.norm.top@tax_table[,t] %in% taxtab.gs[,t]], "*")
}

```

```{r}
if (merge.non.GS.Taxa) {
  gs.taxa          <- unique(taxtab.gs[,t])
  ps.glom.norm.top.merged <- merge.other.Taxa(ps.glom.norm.top, gs.taxa )
} else {
  ps.glom.norm.top.merged <- ps.glom.norm.top
}

```


```{r, Phylum-level plot, fig.height=fig.height.vr, fig.width = fig.width.vr, eval=multiV[2]}

ggtop20    <- plotfun(
  ps.glom.norm.top.merged,
                t=t, fill=t) + 
  theme(legend.position = 'right') +
  ggtitle(paste0('Top', top, ' ', t))

ggtop20

if (save.Figs){
  ggsave(paste0(res.dir, '/', filenames[1], '_Vregions.jpg'), width = fig.width.vr, height = fig.height.vr)
}



ps.glom.norm.top.phy <- ps.glom.norm.top
ps.glom.norm.phy     <- ps.glom.norm
ps.glom.top.phy      <- ps.glom.top
ps.glom.phy          <- ps.glom


```

## Class level

```{r, Glom taxa at Class-level}
n <- 3

t <- rank_names(ps)[n]

## glomerate at n taxonomic level, regardless of lineage
ps.glom <- tax_glom_fast(ps, rank_level = n, ignore_lineage = T)

## normalize PS object per taxon sums
ps.glom.norm       <- norm.ps(ps.glom, 'sum')

## top20 taxa from the glomerated at specific tax level
top.taxa           <- names(sort(taxa_sums(ps.glom.norm), decreasing=TRUE))[1:top]

## add all Gold standard taxa?
if (add.GS.taxa) {
 top.taxa  <- unique(c(top.taxa, taxtab.gs[,t]))
}

## prune normalized taxa
ps.glom.norm.top   <- prune_taxa(top.taxa, ps.glom.norm)
## prune taxa
ps.glom.top        <- prune_taxa(top.taxa, ps.glom)

## normalize PS object per taxon sums
ps.glom.norm       <- norm.ps(ps.glom, 'sum')

## top20 taxa from the glomerated at specific tax level
top.taxa           <- names(sort(taxa_sums(ps.glom.norm), decreasing=TRUE))[1:top]

## add all Gold standard taxa?
if (add.GS.taxa) {
  top.taxa  <- unique(c(top.taxa, taxtab.gs[,t]))
}

## prune normalized taxa
ps.glom.norm.top   <- prune_taxa(top.taxa, ps.glom.norm)
## prune taxa
ps.glom.top        <- prune_taxa(top.taxa, ps.glom)

## get data
ps.data.glom.top  <- df.from.ps(ps.glom.top,   comb=F)
ps.data.glom      <- df.from.ps(ps.glom,       comb=F)

## filenames for plots and tables
filenames <- c(
  paste0(res.dir, '_top' , top, '_', t, '_ratios'),
  paste0(res.dir, '_all_', t,           '_ratios') 
)
## write tables
if (writetables){
 write_tsv(ps.data.glom.top, paste0(res.dir, '/', filenames[1], '.tsv')) 
 write_tsv(ps.data.glom,     paste0(res.dir, '/', filenames[2], '.tsv')) 
}

```

```{r}

## Mark GS Taxa with Asterisks
if (mark.GS.Taxa) {
  ps.glom.norm.top@tax_table[,t][ps.glom.norm.top@tax_table[,t] %in% taxtab.gs[,t]] <- paste0(ps.glom.norm.top@tax_table[,t][ps.glom.norm.top@tax_table[,t] %in% taxtab.gs[,t]], "*")
}

```

```{r}
if (merge.non.GS.Taxa) {
  gs.taxa          <- unique(taxtab.gs[,t])
  ps.glom.norm.top.merged <- merge.other.Taxa(ps.glom.norm.top, gs.taxa )
} else {
  ps.glom.norm.top.merged <- ps.glom.norm.top
}

```


```{r, Class-level plot, fig.height = fig.height.vr, fig.width = fig.width.vr, eval=multiV[2]}


ggtop20    <- plotfun(
  ps.glom.norm.top.merged,
                t=t, fill=t) + 
  theme(legend.position = 'right') +
  ggtitle(paste0('Top', top, ' ', t))

ggtop20

if (save.Figs){
  ggsave(paste0(res.dir, '/', filenames[1], '_Vregions.jpg'), width = fig.width.vr, height = fig.height.vr)
}



ps.glom.norm.top.class <- ps.glom.norm.top
ps.glom.norm.class     <- ps.glom.norm
ps.glom.top.class      <- ps.glom.top
ps.glom.class          <- ps.glom

```


## Order level

```{r, Glom taxa at Order-level}
n <- 4

t <- rank_names(ps)[n]

## glomerate at n taxonomic level, regardless of lineage
ps.glom <- tax_glom_fast(ps, rank_level = n, ignore_lineage = T)

## normalize PS object per taxon sums
ps.glom.norm       <- norm.ps(ps.glom, 'sum')

## top20 taxa from the glomerated at specific tax level
top.taxa           <- names(sort(taxa_sums(ps.glom.norm), decreasing=TRUE))[1:top]

## add all Gold standard taxa?
if (add.GS.taxa) {
 top.taxa  <- unique(c(top.taxa, taxtab.gs[,t]))
}

## prune normalized taxa
ps.glom.norm.top   <- prune_taxa(top.taxa, ps.glom.norm)
## prune taxa
ps.glom.top        <- prune_taxa(top.taxa, ps.glom)

## normalize PS object per taxon sums
ps.glom.norm       <- norm.ps(ps.glom, 'sum')

## top20 taxa from the glomerated at specific tax level
top.taxa           <- names(sort(taxa_sums(ps.glom.norm), decreasing=TRUE))[1:top]

## add all Gold standard taxa?
if (add.GS.taxa) {
  top.taxa  <- unique(c(top.taxa, taxtab.gs[,t]))
}

## prune normalized taxa
ps.glom.norm.top   <- prune_taxa(top.taxa, ps.glom.norm)
## prune taxa
ps.glom.top        <- prune_taxa(top.taxa, ps.glom)

## get data
ps.data.glom.top  <- df.from.ps(ps.glom.top,   comb=F)
ps.data.glom      <- df.from.ps(ps.glom,       comb=F)

## filenames for plots and tables
filenames <- c(
  paste0(res.dir, '_top' , top, '_', t, '_ratios'),
  paste0(res.dir, '_all_', t,           '_ratios') 
)
## write tables
if (writetables){
 write_tsv(ps.data.glom.top, paste0(res.dir, '/', filenames[1], '.tsv')) 
 write_tsv(ps.data.glom,     paste0(res.dir, '/', filenames[2], '.tsv')) 
}

```

```{r}

## Mark GS Taxa with Asterisks
if (mark.GS.Taxa) {
  ps.glom.norm.top@tax_table[,t][ps.glom.norm.top@tax_table[,t] %in% taxtab.gs[,t]] <- paste0(ps.glom.norm.top@tax_table[,t][ps.glom.norm.top@tax_table[,t] %in% taxtab.gs[,t]], "*")
}

```

```{r}
if (merge.non.GS.Taxa) {
  gs.taxa          <- unique(taxtab.gs[,t])
  ps.glom.norm.top.merged <- merge.other.Taxa(ps.glom.norm.top, gs.taxa )
} else {
  ps.glom.norm.top.merged <- ps.glom.norm.top
}

```


```{r, Order-level plot, fig.height = fig.height.vr, fig.width = fig.width.vr, eval=multiV[2]}


ggtop20    <- plotfun(
  ps.glom.norm.top.merged,
                t=t, fill=t) + 
  theme(legend.position = 'right') +
  ggtitle(paste0('Top', top, ' ', t))

ggtop20

if (save.Figs){
  ggsave(paste0(res.dir, '/', filenames[1], '_Vregions.jpg'), width = fig.width.vr, height = fig.height.vr)
}



ps.glom.norm.top.ord <- ps.glom.norm.top
ps.glom.norm.ord     <- ps.glom.norm
ps.glom.top.ord      <- ps.glom.top
ps.glom.ord          <- ps.glom

```

## Family level

```{r, Glom taxa at Family-level}
n <- 5

t <- rank_names(ps)[n]

## glomerate at n taxonomic level, regardless of lineage
ps.glom <- tax_glom_fast(ps, rank_level = n, ignore_lineage = T)

## normalize PS object per taxon sums
ps.glom.norm       <- norm.ps(ps.glom, 'sum')

## top20 taxa from the glomerated at specific tax level
top.taxa           <- names(sort(taxa_sums(ps.glom.norm), decreasing=TRUE))[1:top]

## add all Gold standard taxa?
if (add.GS.taxa) {
  top.taxa  <- unique(c(top.taxa, taxtab.gs[,t]))
}

## prune normalized taxa
ps.glom.norm.top   <- prune_taxa(top.taxa, ps.glom.norm)
## prune taxa
ps.glom.top        <- prune_taxa(top.taxa, ps.glom)

## normalize PS object per taxon sums
ps.glom.norm       <- norm.ps(ps.glom, 'sum')

## top20 taxa from the glomerated at specific tax level
top.taxa           <- names(sort(taxa_sums(ps.glom.norm), decreasing=TRUE))[1:top]

## add all Gold standard taxa?
if (add.GS.taxa) {
  top.taxa  <- unique(c(top.taxa, taxtab.gs[,t]))
}

## prune normalized taxa
ps.glom.norm.top   <- prune_taxa(top.taxa, ps.glom.norm)
## prune taxa
ps.glom.top        <- prune_taxa(top.taxa, ps.glom)

## get data
ps.data.glom.top  <- df.from.ps(ps.glom.top,   comb=F)
ps.data.glom      <- df.from.ps(ps.glom,       comb=F)

## filenames for plots and tables
filenames <- c(
  paste0(res.dir, '_top' , top, '_', t, '_ratios'),
  paste0(res.dir, '_all_', t,           '_ratios') 
)
## write tables
if (writetables){
 write_tsv(ps.data.glom.top, paste0(res.dir, '/', filenames[1], '.tsv')) 
 write_tsv(ps.data.glom,     paste0(res.dir, '/', filenames[2], '.tsv')) 
}

```

```{r}

## Mark GS Taxa with Asterisks
if (mark.GS.Taxa) {
  ps.glom.norm.top@tax_table[,t][ps.glom.norm.top@tax_table[,t] %in% taxtab.gs[,t]] <- paste0(ps.glom.norm.top@tax_table[,t][ps.glom.norm.top@tax_table[,t] %in% taxtab.gs[,t]], "*")
}

```

```{r}
if (merge.non.GS.Taxa) {
  gs.taxa          <- unique(taxtab.gs[,t])
  ps.glom.norm.top.merged <- merge.other.Taxa(ps.glom.norm.top, gs.taxa )
} else {
  ps.glom.norm.top.merged <- ps.glom.norm.top
}

```


```{r, Family-level plot, fig.height = fig.height.vr, fig.width = fig.width.vr, eval=multiV[2]}

ggtop20    <- plotfun(
  ps.glom.norm.top.merged,
                t=t, fill=t) + 
  theme(legend.position = 'right') +
  ggtitle(paste0('Top', top, ' ', t))

ggtop20

if (save.Figs){
  ggsave(paste0(res.dir, '/', filenames[1], '_Vregions.jpg'), width = fig.width.vr, height = fig.height.vr)
}



ps.glom.norm.top.fam <- ps.glom.norm.top
ps.glom.norm.fam     <- ps.glom.norm
ps.glom.top.fam      <- ps.glom.top
ps.glom.fam          <- ps.glom

```


## Genus level

```{r, Glom taxa at Genus-level}
n <- 6

t <- rank_names(ps)[n]

## glomerate at n taxonomic level, regardless of lineage
ps.glom <- tax_glom_fast(ps, rank_level = n, ignore_lineage = T)

## normalize PS object per taxon sums
ps.glom.norm       <- norm.ps(ps.glom, 'sum')

## top20 taxa from the glomerated at specific tax level
top.taxa           <- names(sort(taxa_sums(ps.glom.norm), decreasing=TRUE))[1:top]

## add all Gold standard taxa?
if (add.GS.taxa) {
  top.taxa  <- unique(c(top.taxa, taxtab.gs[,t]))
}

## prune normalized taxa
ps.glom.norm.top   <- prune_taxa(top.taxa, ps.glom.norm)
## prune taxa
ps.glom.top        <- prune_taxa(top.taxa, ps.glom)

## normalize PS object per taxon sums
ps.glom.norm       <- norm.ps(ps.glom, 'sum')

## top20 taxa from the glomerated at specific tax level
top.taxa           <- names(sort(taxa_sums(ps.glom.norm), decreasing=TRUE))[1:top]

## add all Gold standard taxa?
if (add.GS.taxa) {
  top.taxa  <- unique(c(top.taxa, taxtab.gs[,t]))
}

## prune normalized taxa
ps.glom.norm.top   <- prune_taxa(top.taxa, ps.glom.norm)
## prune taxa
ps.glom.top        <- prune_taxa(top.taxa, ps.glom)

## get data
ps.data.glom.top  <- df.from.ps(ps.glom.top,   comb=F)
ps.data.glom      <- df.from.ps(ps.glom,       comb=F)

## filenames for plots and tables
filenames <- c(
  paste0(res.dir, '_top' , top, '_', t, '_ratios'),
  paste0(res.dir, '_all_', t,           '_ratios') 
)
## write tables
if (writetables){
 write_tsv(ps.data.glom.top, paste0(res.dir, '/', filenames[1], '.tsv')) 
 write_tsv(ps.data.glom,     paste0(res.dir, '/', filenames[2], '.tsv')) 
}

```

```{r}

## Mark GS Taxa with Asterisks
if (mark.GS.Taxa) {
  ps.glom.norm.top@tax_table[,t][ps.glom.norm.top@tax_table[,t] %in% taxtab.gs[,t]] <- paste0(ps.glom.norm.top@tax_table[,t][ps.glom.norm.top@tax_table[,t] %in% taxtab.gs[,t]], "*")
}

```

```{r}
if (merge.non.GS.Taxa) {
  gs.taxa          <- unique(taxtab.gs[,t])
  ps.glom.norm.top.merged <- merge.other.Taxa(ps.glom.norm.top, gs.taxa )
} else {
  ps.glom.norm.top.merged <- ps.glom.norm.top
}

```


```{r, Genus-level plot, fig.height = fig.height.vr, fig.width = fig.width.vr, eval=multiV[2]}

ggtop20    <- plotfun(
  ps.glom.norm.top.merged,
                t=t, fill=t) + 
  theme(legend.position = 'right') +
  ggtitle(paste0('Top', top, ' ', t))

ggtop20

if (save.Figs){
  ggsave(paste0(res.dir, '/', filenames[1], '_Vregions.jpg'), width = fig.width.vr, height = fig.height.vr)
}



ps.glom.norm.top.gen <- ps.glom.norm.top
ps.glom.norm.gen     <- ps.glom.norm
ps.glom.top.gen      <- ps.glom.top
ps.glom.gen          <- ps.glom

```


## Species level

```{r, Glom taxa at Species-level}
n <- 7

t <- rank_names(ps)[n]

## glomerate at n taxonomic level, regardless of lineage
#if (!all(taxa_names(ps) == data.frame(ps@tax_table$species))) {
  ps.glom <- tax_glom_fast(ps, rank_level = n, ignore_lineage = T)  
#} else {
#  ps.glom <- ps
#}


## normalize PS object per taxon sums
ps.glom.norm       <- norm.ps(ps.glom, 'sum')

## top20 taxa from the glomerated at specific tax level
top.taxa           <- names(sort(taxa_sums(ps.glom.norm), decreasing=TRUE))[1:top]

## add all Gold standard taxa?
if (add.GS.taxa) {
  top.taxa  <- unique(c(top.taxa, taxtab.gs[,t]))
}

## prune normalized taxa
ps.glom.norm.top   <- prune_taxa(top.taxa, ps.glom.norm)
## prune taxa
ps.glom.top        <- prune_taxa(top.taxa, ps.glom)

## normalize PS object per taxon sums
ps.glom.norm       <- norm.ps(ps.glom, 'sum')

## top20 taxa from the glomerated at specific tax level
top.taxa           <- names(sort(taxa_sums(ps.glom.norm), decreasing=TRUE))[1:top]

## add all Gold standard taxa?
if (add.GS.taxa) {
  top.taxa  <- unique(c(top.taxa, taxtab.gs[,t]))
}

## prune normalized taxa
ps.glom.norm.top   <- prune_taxa(top.taxa, ps.glom.norm)
## prune taxa
ps.glom.top        <- prune_taxa(top.taxa, ps.glom)

## get data
ps.data.glom.top  <- df.from.ps(ps.glom.top,   comb=F)
ps.data.glom      <- df.from.ps(ps.glom,       comb=F)

## filenames for plots and tables
filenames <- c(
  paste0(res.dir, '_top' , top, '_', t, '_ratios'),
  paste0(res.dir, '_all_', t,           '_ratios') 
)
## write tables
if (writetables){
 write_tsv(ps.data.glom.top, paste0(res.dir, '/', filenames[1], '.tsv')) 
 write_tsv(ps.data.glom,     paste0(res.dir, '/', filenames[2], '.tsv')) 
}

```

```{r}

## Mark GS Taxa with Asterisks
if (mark.GS.Taxa) {
  ps.glom.norm.top@tax_table[,t][ps.glom.norm.top@tax_table[,t] %in% taxtab.gs[,t]] <- paste0(ps.glom.norm.top@tax_table[,t][ps.glom.norm.top@tax_table[,t] %in% taxtab.gs[,t]], "*")
}

```

```{r}
if (merge.non.GS.Taxa) {
  gs.taxa          <- unique(taxtab.gs[,t])
  ps.glom.norm.top.merged <- merge.other.Taxa(ps.glom.norm.top, gs.taxa )
} else {
  ps.glom.norm.top.merged <- ps.glom.norm.top
}

```


```{r, Species-level plot, fig.height = fig.height.vr, fig.width = fig.width.vr, eval=multiV[2]}

ggtop20    <- plotfun(
  ps.glom.norm.top.merged,
                t=t, fill=t) + 
  theme(legend.position = 'right') +
  ggtitle(paste0('Top', top, ' ', t))

ggtop20

if (save.Figs){
  ggsave(paste0(res.dir, '/', filenames[1], '_Vregions.jpg'), width = fig.width.vr, height = fig.height.vr)
}



ps.glom.norm.top.spec <- ps.glom.norm.top
ps.glom.norm.spec     <- ps.glom.norm
ps.glom.top.spec      <- ps.glom.top
ps.glom.spec          <- ps.glom

```
 
## Figure XB -- no eval
```{r, Figure XB, fig.height = fig.height.vr*1.5, fig.width = fig.width.vr, eval=F}

n <- 6
t <- rank_names(ps)[n]

## Mark GS Taxa with Asterisks
if (mark.GS.Taxa) {
  ps.glom.norm.top.gen@tax_table[,t][ps.glom.norm.top.gen@tax_table[,t] %in% taxtab.gs[,t]] <- paste0(ps.glom.norm.top.gen@tax_table[,t][ps.glom.norm.top.gen@tax_table[,t] %in% taxtab.gs[,t]], "*")
}

## Merge non-GS Taxa
if (merge.non.GS.Taxa) {
  gs.taxa          <- unique(taxtab.gs[,t])
  ps.glom.norm.top.merged <- merge.other.Taxa(ps.glom.norm.top.gen, gs.taxa )
} else {
  ps.glom.norm.top.merged <- ps.glom.norm.top.gen
}


fig4d    <- plotfun(
  ps.glom.norm.top.merged,
                t=t, fill=t) + 
  theme(legend.position = 'right') +
  ggtitle('b')

ggsave(paste0('FIGURES_REVISION', '/', 'Figure YB.jpg'), 
       width = fig.width.vr, height = fig.height.vr)

fig4d


saveRDS(ps.glom.norm.top.merged, paste0(res.dir, '/ps.glom.norm.top.gen.merged.rds'))
```


# Statistics: Correlations, Significantly Differnet Taxa, PERMANOVA

*TIDY UP THE CODE HERE!*

```{r}

ps <- ps.all

plot_correl <- function(plot_data, vars=c('sample', 'method', 'R2', 'source', 'primer', 'sample_name')) {
  ggplot(plot_data, aes(x = Observed, y = Theoretical, color = Taxa)) +
  geom_point() +
  geom_abline(intercept = 0, slope = 1, linetype = "dashed", color = "red") +
  geom_label_repel(data = data.frame(unique.data.frame(plot_data[,vars]), x=0, y=1, Taxa=''),
            aes(x=x, y=y, label = paste0('R2=', round(R2, 3))), nudge_x = 0.02, nudge_y = -0.02, size = 3) +
  guides(color = guide_legend(direction = "vertical", ncol = 1)) +
  scale_color_manual(values=as.character(pal.man)) +
  facet_wrap(~ sample, scales = "free") +
  #coord_cartesian(xlim = c(0,1), ylim = c(0,1)) +
  theme_ipsum() + 
  theme(legend.position="right",
        legend.text = element_text(face = "italic")) +
  facet_nested(rows=vars(source, primer), cols=vars(method), scales = 'fixed') +
  labs(
    x = "Observed Composition",
    y = "Theoretical Composition",
    title = "Observed vs Theoretical Composition by Method"
  )


}
```



## Phylum level

```{r}
n <- 2
t <- rank_names(ps.all)[n]

if (correl == 'all') {
  ps <- ps.glom.norm.phy
} else if (correl == 'topN') {
  ps <- ps.glom.norm.top.phy
}
sampdat <- data.frame(sample_data(ps))


data <- data.frame(
  data.frame(otu_table(prune_samples(grep(GS_name, sample_names(ps), value = T, invert = T), ps))),
  setNames(
    as.data.frame(data.frame(otu_table(prune_samples(grep(GS_name, sample_names(ps), value = T, invert = F), ps)))[,1]),
    'Theoretical')
)
## the last column here is the Theoretical!

data <- data.frame(taxon=rownames(data), data)

## 
data[,'taxon'] <- gsub('.*;', '', data[,'taxon'])

# Calculate R-squared values for each method's correlation with the theoretical composition
r2_values <- data %>%
  mutate(across(-taxon, ~ cor(.x, Theoretical)^2, .names = "r2_{.col}")) %>% 
  select(starts_with("r2_")) %>%
  gather(sample, r2) %>% 
  unique.data.frame()
r2_values$sample <- gsub('r2_', '', r2_values$sample)

obs_data <- data %>%
  mutate(across(-taxon, ~ cor(.x, Theoretical)^2, .names = "r2_{.col}")) %>% 
  select(taxon, !starts_with("r2_")) %>%
  gather(sample, Observed, -1) %>% 
  unique.data.frame()  %>%
  filter(sample!='Theoretical')

theor_data <- data %>%
  mutate(across(-taxon, ~ cor(.x, Theoretical)^2, .names = "r2_{.col}")) %>% 
  select(taxon, !starts_with("r2_")) %>%
  gather(sample, Theoretical, -1) %>% 
  unique.data.frame()  %>%
  filter(sample=='Theoretical') %>%
  select(!starts_with("sample"))


plot_data <- merge(theor_data, obs_data, by=c('taxon'))

plot_data <- merge(plot_data, r2_values, by=c('sample'))

colnames(plot_data)[c(2,5)]  <- c('Taxa', 'R2')
plot_data$rank <- t

plot_data_corr_phy <- merge(plot_data, sampdat, by.x=c('sample'), by.y=0, all.x=T)

```


### R² for each sample

```{r, fig.width=24, fig.height=9}
# Create a scatter plot with R-squared values
plot_correl(plot_data_corr_phy)
```


### Pairwise comparison between minitax (LCA) and EMU
```{r, eval=F}
data.mt <- 
  merge(melt(data, value.name = 'abundance', variable.name = 'sample'),
      sampdat, by='sample')
setDT(data.mt)

data.mt[,method_nr := seq_along(sample), by=.(taxon, method, primer)]

data.sp <- dcast(data.mt, primer + sample_name + taxon ~ method, value.var = 'abundance')
data.sp[,method_nr := .GRP,  by=.(sample_name, primer)]

ggpaired(data.sp, "LCA", "EMU",
         line.color = "gray", 
         fill='condition',
         palette = c("#FC4E07", "#00AFBB"), 
         xlab = "Isolation Method", 
         ylab = "Abundance", 
         title = "Paired Abundance Comparison between Methods and Primers") + 
  theme(strip.text.x.top = element_text(face='italic'),
        legend.position = 'none') + 
  facet_wrap(~taxon+primer, scales = 'free_y', ncol = 6)
  #facet_nested(cols=vars(primer), rows=vars(taxon), scales = 'free_y')

ggpaired(data.sp, "LCA", "EMU",
         line.color = "gray", 
         fill='condition',
         palette = c("#FC4E07", "#00AFBB"), 
         xlab = "Isolation Method", 
         ylab = "Abundance", 
         title = "Paired Abundance Comparison between Methods") + 
  theme(strip.text.x.top = element_text(face='italic'),
        legend.position = 'none') + 
  facet_wrap(~taxon, scales = 'free_y', ncol = 3)
  #facet_nested(cols=vars(primer), rows=vars(taxon), scales = 'free_y')


```




## Order level
```{r, fig.width=15, fig.height=14}
n <- 4
t <- rank_names(ps.all)[n]

if (correl == 'all') {
  ps <- ps.glom.norm.ord
} else if (correl == 'topN') {
  ps <- ps.glom.norm.top.ord
}
sampdat <- data.frame(sample_data(ps))



data <- data.frame(
  data.frame(otu_table(prune_samples(grep(GS_name, sample_names(ps), value = T, invert = T), ps))),
  setNames(
    as.data.frame(data.frame(otu_table(prune_samples(grep(GS_name, sample_names(ps), value = T, invert = F), ps)))[,1]),
    'Theoretical')
)
## the last column here is the Theoretical!

data <- data.frame(taxon=rownames(data), data)
## 
data[,'taxon'] <- gsub('.*;', '', data[,'taxon'])

# Calculate R-squared values for each method's correlation with the theoretical composition
r2_values <- data %>%
  mutate(across(-taxon, ~ cor(.x, Theoretical)^2, .names = "r2_{.col}")) %>% 
  select(starts_with("r2_")) %>%
  gather(sample, r2) %>% 
  unique.data.frame()
r2_values$sample <- gsub('r2_', '', r2_values$sample)

obs_data <- data %>%
  mutate(across(-taxon, ~ cor(.x, Theoretical)^2, .names = "r2_{.col}")) %>% 
  select(taxon, !starts_with("r2_")) %>%
  gather(sample, Observed, -1) %>% 
  unique.data.frame()  %>%
  filter(sample!='Theoretical')

theor_data <- data %>%
  mutate(across(-taxon, ~ cor(.x, Theoretical)^2, .names = "r2_{.col}")) %>% 
  select(taxon, !starts_with("r2_")) %>%
  gather(sample, Theoretical, -1) %>% 
  unique.data.frame()  %>%
  filter(sample=='Theoretical') %>%
  select(!starts_with("sample"))


plot_data <- merge(theor_data, obs_data, by=c('taxon'))

plot_data <- merge(plot_data, r2_values, by=c('sample'))

colnames(plot_data)[c(2,5)]  <- c('Taxa', 'R2')
plot_data$rank <- t

plot_data_corr_ord <- merge(plot_data, sampdat, by.x=c('sample'), by.y=0, all.x=T)


```

```{r, fig.width=24, fig.height=9}
# Create a scatter plot with R-squared values
plot_correl(plot_data_corr_ord)
```


## Genus level
```{r, fig.width=24, fig.height=9}
n <- 6
t <- rank_names(ps.all)[n]

if (correl == 'all') {
  ps <- ps.glom.norm.gen
} else if (correl == 'topN') {
  ps <- ps.glom.norm.top.gen
}
sampdat <- data.frame(sample_data(ps))

data <- data.frame(
  data.frame(otu_table(prune_samples(grep(GS_name, sample_names(ps), value = T, invert = T), ps))),
  setNames(
    as.data.frame(data.frame(otu_table(prune_samples(grep(GS_name, sample_names(ps), value = T, invert = F), ps)))[,1]),
    'Theoretical')
)
## the last column here is the Theoretical!

data <- data.frame(taxon=rownames(data), data)

## 
data[,'taxon'] <- gsub('.*;', '', data[,'taxon'])

# Calculate R-squared values for each method's correlation with the theoretical composition
r2_values <- data %>%
  mutate(across(-taxon, ~ cor(.x, Theoretical)^2, .names = "r2_{.col}")) %>% 
  select(starts_with("r2_")) %>%
  gather(sample, r2) %>% 
  unique.data.frame()
r2_values$sample <- gsub('r2_', '', r2_values$sample)

obs_data <- data %>%
  mutate(across(-taxon, ~ cor(.x, Theoretical)^2, .names = "r2_{.col}")) %>% 
  select(taxon, !starts_with("r2_")) %>%
  gather(sample, Observed, -1) %>% 
  unique.data.frame()  %>%
  filter(sample!='Theoretical')

theor_data <- data %>%
  mutate(across(-taxon, ~ cor(.x, Theoretical)^2, .names = "r2_{.col}")) %>% 
  select(taxon, !starts_with("r2_")) %>%
  gather(sample, Theoretical, -1) %>% 
  unique.data.frame()  %>%
  filter(sample=='Theoretical') %>%
  select(!starts_with("sample"))


plot_data <- merge(theor_data, obs_data, by=c('taxon'))

plot_data <- merge(plot_data, r2_values, by=c('sample'))

colnames(plot_data)[c(2,5)]  <- c('Taxa', 'R2')
plot_data$rank <- t

plot_data_corr_gen <- merge(plot_data, sampdat, by.x=c('sample'), by.y=0, all.x=T)


```

```{r, fig.width=24, fig.height=9}
# Create a scatter plot with R-squared values
plot_correl(plot_data_corr_gen)
```


## Species level
```{r, fig.width=24, fig.height=9}
n <- 7
t <- rank_names(ps.all)[n]

if (correl == 'all') {
  ps <- ps.glom.norm.spec
} else if (correl == 'topN') {
  ps <- ps.glom.norm.top.spec
}

sampdat <- data.frame(sample_data(ps))


data <- data.frame(
  data.frame(otu_table(prune_samples(grep(GS_name, sample_names(ps), value = T, invert = T), ps))),
  setNames(
    as.data.frame(data.frame(otu_table(prune_samples(grep(GS_name, sample_names(ps), value = T, invert = F), ps)))[,1]),
    'Theoretical')
)
## the last column here is the Theoretical!

data <- data.frame(taxon=rownames(data), data)

## 
data[,'taxon'] <- gsub('.*;', '', data[,'taxon'])

# Calculate R-squared values for each method's correlation with the theoretical composition
r2_values <- data %>%
  mutate(across(-taxon, ~ cor(.x, Theoretical)^2, .names = "r2_{.col}")) %>% 
  select(starts_with("r2_")) %>%
  gather(sample, r2) %>% 
  unique.data.frame()
r2_values$sample <- gsub('r2_', '', r2_values$sample)

obs_data <- data %>%
  mutate(across(-taxon, ~ cor(.x, Theoretical)^2, .names = "r2_{.col}")) %>% 
  select(taxon, !starts_with("r2_")) %>%
  gather(sample, Observed, -1) %>% 
  unique.data.frame()  %>%
  filter(sample!='Theoretical')

theor_data <- data %>%
  mutate(across(-taxon, ~ cor(.x, Theoretical)^2, .names = "r2_{.col}")) %>% 
  select(taxon, !starts_with("r2_")) %>%
  gather(sample, Theoretical, -1) %>% 
  unique.data.frame()  %>%
  filter(sample=='Theoretical') %>%
  select(!starts_with("sample"))


plot_data <- merge(theor_data, obs_data, by=c('taxon'))

plot_data <- merge(plot_data, r2_values, by=c('sample'))

colnames(plot_data)[c(2,5)]  <- c('Taxa', 'R2')
plot_data$rank <- t

plot_data_corr_spec <- merge(plot_data, sampdat, by.x=c('sample'), by.y=0, all.x=T)

```

```{r, fig.width=24, fig.height=9}
# Create a scatter plot with R-squared values
plot_correl(plot_data_corr_spec)
```


## Summarised r2 values

```{r, R2 sum, fig.width=20, fig.height=20, eval=T}
# Create a scatter plot with R-squared values

plot_data <- plyr::rbind.fill(plot_data_corr_phy,
                              plot_data_corr_ord,
                              plot_data_corr_gen,
                              plot_data_corr_spec)

plot_sum  <- unique.data.frame(plot_data[,c(colnames(metadata), 'rank', 'R2')])
setDT(plot_sum)


# Calculate means, standard deviations, and include p-values and significance
plot_means <- plot_sum[, .(R2_mean = mean(R2), R2_sd = sd(R2)), by = .(source, method, primer, rank)]

# Ensure primer is a factor in both plot_means and tukey_labels
plot_means[, primer := factor(primer, levels = unique(plot_means$primer))]


# Plotting with means, standard deviations, and significance labels
ggplot(plot_means, aes(x = primer, y = R2_mean)) +
  geom_col(aes(fill = primer), position = position_dodge2()) +
  geom_errorbar(aes(ymin = R2_mean - R2_sd, ymax = R2_mean + R2_sd, fill = primer), width = 0.2, position = position_dodge2()) +
  scale_fill_manual(values = as.character(pal.man[])) +
  theme_ipsum() + 
  theme(legend.position = "right",
        axis.text.x = element_text(angle = -60)
        #,panel.spacing.x = unit(0.1, 'mm')
        ) +
  facet_nested(cols = vars(method),
               rows = vars(rank),
               scales = 'free_x')


```



# Detection Statistics based on Taxa presence/absence on different levels


- Precision= true positives /(true positives + false positives) \n
- Recall= true positives /(true positives + false negatives) \n
- F1=(2∗ precision ∗ recall)/(precision + recall) \n
- F0.5=((1+0.52)∗ precision ∗ recall)/((0.52∗ precision)+ recall) \n

```{r, Calculate detection stats for Species}
detect.tresh.ratios <- c(0.01, 0.001, 0.0001)  # -->> 0.1 %

otutab.gsa      <-  data.frame(taxon=taxa_names(ps.gsa), otu_table(ps.gsa))
otutab.gsa      <-  otutab.gsa[,1:2]
otutab.gsa[,2]  <- (otutab.gsa[,2] / sum(otutab.gsa[,2], na.rm=T)) * 100
all.sample.stat.df <- data.frame(NULL)

ps <- ps.all
samples <- grep(GS_name, sample_names(ps), invert = T, value = T)
sample  <- samples[1]
for (sample in samples) {
  ps.sub         <- prune_samples(sample, ps)
  otutab.sub     <- data.frame(taxon=taxa_names(ps), otu_table(ps.sub))
  
  ## Calculate staitstics for each Detection threshold
  sample.stat.df <- data.frame(NULL)
  for (detect.tresh.ratio in detect.tresh.ratios) {
    detect.tresh   <- detect.tresh.ratio * sum(otutab.sub[,sample])
    
    otutab.sub.det <- as.data.frame(otutab.sub[otutab.sub[,2] > detect.tresh,])  #; colnames(otutab.sub.det)[2] <- sample
    
    otutab.sub.det[,sample] <- (otutab.sub.det[,sample] / sum(otutab.sub.det[,sample], na.rm=T)) * 100
    
    ## Merge Estimated abundances with Theoretical
    otutab.sub.merge <- merge(otutab.sub.det, otutab.gsa, by='taxon', all=T)
    ## COL 2 -->> Estimated
    ## COL 3 -->> Theoretical
    
    ## Set abundance to 0
    otutab.sub.merge[is.na(otutab.sub.merge[,2]), 2] <- 0
    otutab.sub.merge[is.na(otutab.sub.merge[,3]), 3] <- 0
    
    ## Taxa presence / absence : count TP, FP and FN
    TP               <- nrow(otutab.sub.merge[otutab.sub.merge[,2] >  0 & otutab.sub.merge[,3] >  0, ])
    FP               <- nrow(otutab.sub.merge[otutab.sub.merge[,2] >  0 & otutab.sub.merge[,3] == 0, ])
    FN               <- nrow(otutab.sub.merge[otutab.sub.merge[,2] == 0 & otutab.sub.merge[,3] >  0, ])
    
    ## Absolute and Relative Error, for Theoretical and Measured abundance comparison
    otutab.sub.merge$Abs_Error <- abs(otutab.sub.merge[,3] - otutab.sub.merge[,2])
    otutab.sub.merge$Rel_Error <- 100 * (otutab.sub.merge$Abs_Error / otutab.sub.merge[,3])
    
    ## Chi statistic for Chi-squared test
    otutab.sub.merge$Chi_stat <- otutab.sub.merge$Abs_Error^2 / otutab.sub.merge[,3]
    
    ## L1 (Manhattan) distance is the sum of Absoulte Errors
    ## Chi-squared statistic is the sum of the squared differences
    
    ## For True Positives
    distance_TP_sample  <- otutab.sub.merge[otutab.sub.merge[,3] != 0, ]
    distance_TP_sample  <- plyr::rbind.fill(distance_TP_sample, data.frame(rbind(colSums(distance_TP_sample[,-1], na.rm=T))))
    distance_TP_sample[nrow(distance_TP_sample), 1] <- 'Error_Sum'
    
    ## Calculate the same for False Positives
    distance_FP_sample     <- otutab.sub.merge[otutab.sub.merge[,2] !=0 &  otutab.sub.merge[,3] == 0, ]
    distance_FP_sample     <- plyr::rbind.fill(distance_FP_sample, data.frame(rbind(colSums(distance_FP_sample[,-1], na.rm=T))))
    distance_FP_sample[nrow(distance_FP_sample), 1] <- 'Error_Sum'
   
    ## Cary out Chi-squared test
    Chi_stat <- distance_TP_sample[nrow(distance_TP_sample), 'Chi_stat']
    ## Degrees of Freedom
    df       <- nrow(distance_TP_sample) - 1
    ## P-value
    p_value <- 1 - pchisq(Chi_stat, df)
    ## Bonferroni Correction:
    p.value_thresh <- 0.05 / nrow(distance_TP_sample)

    if (p_value < p.value_thresh) {
      chi_sig <- T
      #cat("Reject the null hypothesis: Observed distribution is significantly different from the theoretical distribution.\n")
    } else {
      chi_sig <- F
      #cat("Fail to reject the null hypothesis: Observed distribution is not significantly different from the theoretical distribution.\n")
    }
    
    ## Detection metrics
    Precision <- TP/(TP + FP)
    Recall    <- TP/(TP + FN)
    ## F-scores
    F1        <- (2 * Precision * Recall) / (Precision + Recall)
    F0.5      <- (( 1 + 0.5^2) * Precision * Recall ) / ((0.5^2 * Precision) + Recall)
    ## 
    stat.df        <- data.frame(sample=sample, Detection_threshold_ratio=detect.tresh.ratio, Detection_threshold=detect.tresh,
                                 True_positives=TP, False_positives=FP, False_negatives=FN,
                                 Precision=Precision, Recall=Recall, F1=F1, F0.5=F0.5, 
                                 Chi_stat=Chi_stat, Chisq.test.p_value=p_value, Chisq.test.sign=chi_sig)
    sample.stat.df <- plyr::rbind.fill(stat.df, sample.stat.df)
  }
  
  all.sample.stat.df <- plyr::rbind.fill(all.sample.stat.df, sample.stat.df)
}

all.sample.stat.df <- merge(sample_data(ps), all.sample.stat.df, by.y='sample', by.x=0)
 
all.sample.stat.df.gt <- all.sample.stat.df %>% gather(statistic, value, -c(1:(ncol(sample_data(ps))+3)))
all.sample.stat.df.gt$Detection_threshold_percent <- factor(paste0(as.character(all.sample.stat.df.gt$Detection_threshold_ratio * 100), '%'))

all.species.stat.df <- data.frame(all.sample.stat.df.gt, level='Species')

```



```{r, Plot Species Detection stats, fig.width=10, fig.height=12}
gg.01 <- ggplot(
  all.sample.stat.df.gt[
    all.sample.stat.df.gt$Detection_threshold_ratio == detect.tresh.ratios[1]
  & !is.element(all.sample.stat.df.gt$statistic, c('True_positives', 'False_positives', 'False_negatives', 'Chi_stat', 'Chisq.test.p_value', 'Chisq.test.sign'))
    , ]) +
    geom_col(aes(x=sample_name, y=value, fill=primer), position=position_dodge2()) +
    #geom_jitter(aes(x=workflow, y=value, color=DNA_isolation_method)) +
    #geom_point(aes(x=workflow, y=value, color=statistic)) +
  scale_fill_manual(values = pal.man) +
  coord_cartesian(ylim = c(0,1)) +
  theme_ipsum() +
  facet_nested(cols=vars(method), rows=vars(statistic), scales = 'free_x') +
  ggtitle(paste0('Detection_threshold_ratio: ', detect.tresh.ratios[1]*100, '%'))
   
gg.001 <- ggplot(
  all.sample.stat.df.gt[
    all.sample.stat.df.gt$Detection_threshold_ratio == detect.tresh.ratios[2]
  & !is.element(all.sample.stat.df.gt$statistic, c('True_positives', 'False_positives', 'False_negatives', 'Chi_stat', 'Chisq.test.p_value', 'Chisq.test.sign'))
    , ]) +
    geom_col(aes(x=sample_name, y=value, fill=primer), position=position_dodge2()) +
    #geom_jitter(aes(x=workflow, y=value, color=DNA_isolation_method)) +
    #geom_point(aes(x=workflow, y=value, color=statistic)) +
  scale_fill_manual(values = pal.man) +
  coord_cartesian(ylim = c(0,1)) +
  theme_ipsum() +
  facet_nested(cols=vars(method), rows=vars(statistic), scales = 'free_x') +
  ggtitle(paste0('Detection_threshold_ratio: ', detect.tresh.ratios[2]*100, '%'))

gg.0001 <- ggplot(
  all.sample.stat.df.gt[
    all.sample.stat.df.gt$Detection_threshold_ratio == detect.tresh.ratios[2]
  & !is.element(all.sample.stat.df.gt$statistic, c('True_positives', 'False_positives', 'False_negatives', 'Chi_stat', 'Chisq.test.p_value', 'Chisq.test.sign'))
    , ]) +
    geom_col(aes(x=sample_name, y=value, fill=primer), position=position_dodge2()) +
    #geom_jitter(aes(x=workflow, y=value, color=DNA_isolation_method)) +
    #geom_point(aes(x=workflow, y=value, color=statistic)) +
  scale_fill_manual(values = pal.man) +
  coord_cartesian(ylim = c(0,1)) +
  theme_ipsum() +
  facet_nested(cols=vars(method), rows=vars(statistic), scales = 'free_x') +
  ggtitle(paste0('Detection_threshold_ratio: ', detect.tresh.ratios[3]*100, '%'))


#gg.stats <- cowplot::plot_grid(gg.01, gg.001, gg.0001, ncol=1)


### Detection level: 1%

#gg.01


### Detection level: 0.1%,

#gg.001


### Detection level: 0.01%

#gg.0001
```


```{r, fig.width=32, fig.height=18}
gg.ds <- ggplot(
  all.sample.stat.df.gt[
    #all.sample.stat.df.gt$Detection_threshold_ratio == detect.tresh.ratios[2] &
   !is.element(all.sample.stat.df.gt$statistic, c('True_positives', 'False_positives', 'False_negatives', 'Chi_stat', 'Chisq.test.p_value', 'Chisq.test.sign'))
    , ]) +
    geom_col(aes(x=sample_name, y=value, fill=primer), position=position_dodge2()) +
    #geom_jitter(aes(x=workflow, y=value, color=DNA_isolation_method)) +
    #geom_point(aes(x=workflow, y=value, color=statistic)) +
  scale_fill_manual(values = pal.man) +
  coord_cartesian(ylim = c(0,1)) +
  theme_ipsum() +
  theme(axis.text.x = element_text(angle = -60)) +
  facet_nested(cols=vars(Detection_threshold_percent, method), 
               rows=vars(statistic), scales = 'free') +
  ggtitle(paste0('Species Detection Statistics'))

gg.ds

```


```{r, Correlation of Precision and Recall, fig.width=8, fig.height=6, eval=F}
sum.sample.stat.df.gt <- all.sample.stat.df.gt %>% 
  group_by(source, primer, Detection_threshold_percent, statistic) %>%
  reframe(mean_stat=mean(value), sd_stat=sd(value))
  
plot.data <- sum.sample.stat.df.gt[is.element(sum.sample.stat.df.gt$statistic, c('Precision', 'Recall')),] %>% 
  gather(sum_stat, value, -c(1:4)) #%>% spread(statistic, value)
plot.data$stat <- paste0(plot.data$statistic, '_', plot.data$sum_stat)
plot.data$stat <- gsub('_stat', '', plot.data$stat)
plot.data      <- plot.data[,c(1:3,6,7)] %>% spread(stat,value)


gg.statsum <- ggplot(plot.data) +
  geom_pointrange(aes(y=Recall_mean,    ymin=Recall_mean - Recall_sd,       ymax=Recall_mean    + Recall_sd,
                      x=Precision_mean, xmin=Precision_mean - Precision_sd, xmax=Precision_mean + Precision_sd,
                      color=primer, shape=Detection_threshold_percent)) +
  scale_color_manual(values = pal.man) +
  theme_ipsum() +
  coord_cartesian(xlim=c(0,1), ylim=c(0,1))+
  #facet_nested_wrap(~db, nrow = 1, scales = 'free') +
  #facet_nested(cols=vars(source), rows=vars(primer), scales = 'free_x') +
  ggtitle(paste0('Precision / Recall'))


gg.statsum

```



```{r, Calculate detection stats for Genera }
detect.tresh.ratios <- c(0.01, 0.001, 0.0001)  # -->> 0.1 %

n <- 6
t <- rank_names(ps.all)[n]; rank <- t
## glomerate at n taxonomic level, regardless of lineage
ps        <- ps.all
ps.glom   <- tax_glom_fast(ps, rank_level = n, ignore_lineage = T)
ps        <- ps.glom

ps.gsa.glom <- tax_glom_fast(ps.gsa, rank_level=n, ignore_lineage = T)

## 
otutab.gsa      <-  data.frame(taxon=taxa_names(ps.gsa.glom), otu_table(ps.gsa.glom))
otutab.gsa      <-  otutab.gsa[,1:2]
otutab.gsa[,2]  <- (otutab.gsa[,2] / sum(otutab.gsa[,2], na.rm=T)) * 100
all.sample.stat.df <- data.frame(NULL)

samples <- grep(GS_name, sample_names(ps), invert = T, value = T)
sample  <- samples[1]
for (sample in samples) {
  ps.sub         <- prune_samples(sample, ps)
  otutab.sub     <- data.frame(taxon=taxa_names(ps), otu_table(ps.sub))
  
  ## Calculate staitstics for each Detection threshold
  sample.stat.df <- data.frame(NULL)
  for (detect.tresh.ratio in detect.tresh.ratios) {
    detect.tresh   <- detect.tresh.ratio * sum(otutab.sub[,sample])
    
    otutab.sub.det <- as.data.frame(otutab.sub[otutab.sub[,2] > detect.tresh,])  #; colnames(otutab.sub.det)[2] <- sample
    
    otutab.sub.det[,sample] <- (otutab.sub.det[,sample] / sum(otutab.sub.det[,sample], na.rm=T)) * 100
    
    ## Merge Estimated abundances with Theoretical
    otutab.sub.merge <- merge(otutab.sub.det, otutab.gsa, by='taxon', all=T)
    ## COL 2 -->> Estimated
    ## COL 3 -->> Theoretical
    
    ## Set abundance to 0
    otutab.sub.merge[is.na(otutab.sub.merge[,2]), 2] <- 0
    otutab.sub.merge[is.na(otutab.sub.merge[,3]), 3] <- 0
    
    ## Taxa presence / absence : count TP, FP and FN
    TP               <- nrow(otutab.sub.merge[otutab.sub.merge[,2] >  0 & otutab.sub.merge[,3] >  0, ])
    FP               <- nrow(otutab.sub.merge[otutab.sub.merge[,2] >  0 & otutab.sub.merge[,3] == 0, ])
    FN               <- nrow(otutab.sub.merge[otutab.sub.merge[,2] == 0 & otutab.sub.merge[,3] >  0, ])
    
    ## Absolute and Relative Error, for Theoretical and Measured abundance comparison
    otutab.sub.merge$Abs_Error <- abs(otutab.sub.merge[,3] - otutab.sub.merge[,2])
    otutab.sub.merge$Rel_Error <- 100 * (otutab.sub.merge$Abs_Error / otutab.sub.merge[,3])
    
    ## Chi statistic for Chi-squared test
    otutab.sub.merge$Chi_stat <- otutab.sub.merge$Abs_Error^2 / otutab.sub.merge[,3]
    
    ## L1 (Manhattan) distance is the sum of Absoulte Errors
    ## Chi-squared statistic is the sum of the squared differences
    
    ## For True Positives
    distance_TP_sample  <- otutab.sub.merge[otutab.sub.merge[,3] != 0, ]
    distance_TP_sample  <- plyr::rbind.fill(distance_TP_sample, data.frame(rbind(colSums(distance_TP_sample[,-1], na.rm=T))))
    distance_TP_sample[nrow(distance_TP_sample), 1] <- 'Error_Sum'
    
    ## Calculate the same for False Positives
    distance_FP_sample     <- otutab.sub.merge[otutab.sub.merge[,2] !=0 &  otutab.sub.merge[,3] == 0, ]
    distance_FP_sample     <- plyr::rbind.fill(distance_FP_sample, data.frame(rbind(colSums(distance_FP_sample[,-1], na.rm=T))))
    distance_FP_sample[nrow(distance_FP_sample), 1] <- 'Error_Sum'
   
    ## Cary out Chi-squared test
    Chi_stat <- distance_TP_sample[nrow(distance_TP_sample), 'Chi_stat']
    ## Degrees of Freedom
    df       <- nrow(distance_TP_sample) - 1
    ## P-value
    p_value <- 1 - pchisq(Chi_stat, df)
    ## Bonferroni Correction:
    p.value_thresh <- 0.05 / nrow(distance_TP_sample)

    if (p_value < p.value_thresh) {
      chi_sig <- T
      #cat("Reject the null hypothesis: Observed distribution is significantly different from the theoretical distribution.\n")
    } else {
      chi_sig <- F
      #cat("Fail to reject the null hypothesis: Observed distribution is not significantly different from the theoretical distribution.\n")
    }
    
    ## Detection metrics
    Precision <- TP/(TP + FP)
    Recall    <- TP/(TP + FN)
    ## F-scores
    F1        <- (2 * Precision * Recall) / (Precision + Recall)
    F0.5      <- (( 1 + 0.5^2) * Precision * Recall ) / ((0.5^2 * Precision) + Recall)
    ## 
    stat.df        <- data.frame(sample=sample, Detection_threshold_ratio=detect.tresh.ratio, Detection_threshold=detect.tresh,
                                 True_positives=TP, False_positives=FP, False_negatives=FN,
                                 Precision=Precision, Recall=Recall, F1=F1, F0.5=F0.5, 
                                 Chi_stat=Chi_stat, Chisq.test.p_value=p_value, Chisq.test.sign=chi_sig)
    sample.stat.df <- plyr::rbind.fill(stat.df, sample.stat.df)
  }
  
  all.sample.stat.df <- plyr::rbind.fill(all.sample.stat.df, sample.stat.df)
}

all.sample.stat.df <- merge(sample_data(ps), all.sample.stat.df, by.y='sample', by.x=0)

all.sample.stat.df.gt <- all.sample.stat.df %>% gather(statistic, value, -c(1:(ncol(sample_data(ps))+3)))
all.sample.stat.df.gt$Detection_threshold_percent <- factor(paste0(as.character(all.sample.stat.df.gt$Detection_threshold_ratio * 100), '%'))

all.genera.stat.df  <- data.frame(all.sample.stat.df.gt, level='Genus')
```

```{r, Plot Genus Detection stats, fig.width=10, fig.height=12}
gg.01 <- ggplot(
  all.sample.stat.df.gt[
    all.sample.stat.df.gt$Detection_threshold_ratio == detect.tresh.ratios[1]
  & !is.element(all.sample.stat.df.gt$statistic, c('True_positives', 'False_positives', 'False_negatives', 'Chi_stat', 'Chisq.test.p_value', 'Chisq.test.sign'))
    , ]) +
    geom_col(aes(x=sample_name, y=value, fill=primer), position=position_dodge2()) +
    #geom_jitter(aes(x=workflow, y=value, color=DNA_isolation_method)) +
    #geom_point(aes(x=workflow, y=value, color=statistic)) +
  scale_fill_manual(values = pal.man) +
  coord_cartesian(ylim = c(0,1)) +
  theme_ipsum() +
  facet_nested(cols=vars(method), rows=vars(statistic), scales = 'free_x') +
  ggtitle(paste0('Detection_threshold_ratio: ', detect.tresh.ratios[1]*100, '%'))
   
gg.001 <- ggplot(
  all.sample.stat.df.gt[
    all.sample.stat.df.gt$Detection_threshold_ratio == detect.tresh.ratios[2]
  & !is.element(all.sample.stat.df.gt$statistic, c('True_positives', 'False_positives', 'False_negatives', 'Chi_stat', 'Chisq.test.p_value', 'Chisq.test.sign'))
    , ]) +
    geom_col(aes(x=sample_name, y=value, fill=primer), position=position_dodge2()) +
    #geom_jitter(aes(x=workflow, y=value, color=DNA_isolation_method)) +
    #geom_point(aes(x=workflow, y=value, color=statistic)) +
  scale_fill_manual(values = pal.man) +
  coord_cartesian(ylim = c(0,1)) +
  theme_ipsum() +
  facet_nested(cols=vars(method), rows=vars(statistic), scales = 'free_x') +
  ggtitle(paste0('Detection_threshold_ratio: ', detect.tresh.ratios[2]*100, '%'))

gg.0001 <- ggplot(
  all.sample.stat.df.gt[
    all.sample.stat.df.gt$Detection_threshold_ratio == detect.tresh.ratios[2]
  & !is.element(all.sample.stat.df.gt$statistic, c('True_positives', 'False_positives', 'False_negatives', 'Chi_stat', 'Chisq.test.p_value', 'Chisq.test.sign'))
    , ]) +
    geom_col(aes(x=sample_name, y=value, fill=primer), position=position_dodge2()) +
    #geom_jitter(aes(x=workflow, y=value, color=DNA_isolation_method)) +
    #geom_point(aes(x=workflow, y=value, color=statistic)) +
  scale_fill_manual(values = pal.man) +
  coord_cartesian(ylim = c(0,1)) +
  theme_ipsum() +
  facet_nested(cols=vars(method), rows=vars(statistic), scales = 'free_x') +
  ggtitle(paste0('Detection_threshold_ratio: ', detect.tresh.ratios[3]*100, '%'))


#gg.stats <- cowplot::plot_grid(gg.01, gg.001, gg.0001, ncol=1)


### Detection level: 1%

#gg.01


### Detection level: 0.1%,

#gg.001


### Detection level: 0.01%

#gg.0001
```


```{r, fig.width=32, fig.height=18}
gg.ds <- ggplot(
  all.sample.stat.df.gt[
    #all.sample.stat.df.gt$Detection_threshold_ratio == detect.tresh.ratios[2] &
   !is.element(all.sample.stat.df.gt$statistic, c('True_positives', 'False_positives', 'False_negatives', 'Chi_stat', 'Chisq.test.p_value', 'Chisq.test.sign'))
    , ]) +
    geom_col(aes(x=sample_name, y=value, fill=primer), position=position_dodge2()) +
    #geom_jitter(aes(x=workflow, y=value, color=DNA_isolation_method)) +
    #geom_point(aes(x=workflow, y=value, color=statistic)) +
  scale_fill_manual(values = pal.man) +
  coord_cartesian(ylim = c(0,1)) +
  theme_ipsum() +
  theme(axis.text.x = element_text(angle = -60)) +
  facet_nested(cols=vars(Detection_threshold_percent, method), 
               rows=vars(statistic), scales = 'free') +
  ggtitle(paste0('Genus Detection Statistics'))

gg.ds

```


# Comparison regarding every statistic

```{r }
all.stat.df  <- plyr::rbind.fill(all.species.stat.df, all.genera.stat.df)

if (writetables) {
  write_tsv(all.stat.df[], 
            paste0(res.dir, '/Detection statistics.tsv'))
}

setDT(all.stat.df)

```



```{r, LMM, fig.width=20, fig.height=20, eval=F}
library(data.table)
library(lme4)
library(lmerTest)  # For p-values in LMMs

# Convert method and rank to factors if they are not already
anova_r2$method <- as.factor(anova_r2$method)
anova_r2$rank <- as.factor(anova_r2$rank)
anova_r2$statistic <- as.factor(anova_r2$statistic)

# Fit the LMM
lmm <- lmer(value ~ method + rank + (1 | sample_name), data = anova_r2)

# If you want to include an interaction between method and rank
lmm_interaction <- lmer(value ~ method * rank + (1 | sample_name), data = anova_r2)

```


```{r}

# compare_methods function
compare_methods <- function(data) {
  # Ensure data is a data.table
  if (!is.data.table(data)) {
    data <- as.data.table(data)
  }
  
  # List of MiniTax methods to compare with EMU
  minitax_methods <- c('BestAln', 'RandAln', 'LCA', 'SpeciesEstimate')
  
  # Get unique statistics
  statistics_list <- unique(data$statistic)
  
  # Initialize a list to store results
  results_list <- list()
  
  # Loop over each statistic
  for (stat in statistics_list) {
    # Filter data for the current statistic
    data_stat <- data[statistic == stat]
    
    # Loop over each MiniTax method
    for (method in minitax_methods) {
      # Methods to compare
      methods_to_compare <- c('EMU', method)
      
      
      
      # Check if both methods are present in the data for this statistic
      if (all(methods_to_compare %in% data_stat$method)) {
      
        result_entry <- NULL
        
        try({
          # Filter data for the two methods
          data_filtered <- data_stat[method %in% methods_to_compare]
          
          # Reshape data to wide format
          data_wide <- dcast(data_filtered, 
                             primer + sample_name + rank ~ method, 
                             value.var = 'value')
          
          # Ensure there are no missing values
          data_wide <- na.omit(data_wide)
          
          # Calculate the difference between MiniTax method and EMU
          data_wide[, diff := get(method) - EMU]
          
          # Check for normality of differences using Shapiro-Wilk test
          if (length(data_wide$diff) >= 3) {  # Shapiro-Wilk requires at least 3 observations
            shapiro_test <- shapiro.test(data_wide$diff)
            normality <- ifelse(shapiro_test$p.value > 0.05, TRUE, FALSE)
          } else {
            shapiro_test <- list(p.value = NA)
            normality <- FALSE  # Default to non-normal if not enough data
          }
          
          # Perform the appropriate paired test
          if (normality) {
            test_result <- t.test(data_wide[[method]], data_wide$EMU, paired = TRUE)
            test_used <- 'Paired t-test'
          } else {
            test_result <- wilcox.test(data_wide[[method]], data_wide$EMU, paired = TRUE)
            test_used <- 'Wilcoxon signed-rank test'
          }
          
          # Store the results
          result_entry <- data.table(
            statistic = stat,
            comparison = paste(method, 'vs EMU'),
            method = method,
            test = test_used,
            p_value = test_result$p.value,
            mean_difference = mean(data_wide$diff, na.rm = TRUE),
            normality = normality,
            shapiro_p = shapiro_test$p.value,
            sample_size = nrow(data_wide)
          )
        })  
        # Append to results list
        results_list[[length(results_list) + 1]] <- result_entry
      } else {
        warning(paste('Methods not found in data for statistic:', stat, 'and method:', method))
      }
    }
  }
  
  # Combine all results into a data.table
  results_dt <- rbindlist(results_list)
  return(results_dt)
}
```


```{r}
all.stat.df$level <- tolower(all.stat.df$level)

anova_res_spec <- data.table(NULL)

for(detect.tresh.ratio in detect.tresh.ratios) {
  
  anova_detect <- all.stat.df[Detection_threshold_ratio == detect.tresh.ratio, 
                             .(statistic, value, sample, primer, sample_name, method, rank=level)]
  anova_r2     <- plot_sum   [,.(statistic='R2', value=R2, sample, primer, sample_name, method, rank)]

  anova_stats  <- rbind(anova_r2, anova_detect)

  stat_res_spec <- compare_methods(anova_stats[rank == 'species'] )  
  stat_res_spec[, Detection_threshold_ratio := detect.tresh.ratio]
  
  anova_res_spec <- rbind(anova_res_spec, stat_res_spec)
    
}
anova_res_spec[,rank := 'species']


anova_res_gen <- data.table(NULL)

for(detect.tresh.ratio in detect.tresh.ratios) {
  
  anova_detect <- all.stat.df[Detection_threshold_ratio == detect.tresh.ratio, 
                             .(statistic, value, sample, primer, sample_name, method, rank=level)]
  anova_r2     <- plot_sum   [,.(statistic='R2', value=R2, sample, primer, sample_name, method, rank)]

  anova_stats  <- rbind(anova_r2, anova_detect)

  stat_res_spec <- compare_methods(anova_stats[rank == 'genus'] )  
  stat_res_spec[, Detection_threshold_ratio := detect.tresh.ratio]
  
  anova_res_gen <- rbind(anova_res_gen, stat_res_spec)
    
}
anova_res_gen[,rank := 'genus']


anova_res <- rbind(anova_res_gen, anova_res_spec)


anova_res[,is.significant := fifelse(p_value <= 0.05, T, F)]
```
```{r}
# Ensure 'statistic' column is treated as a character
anova_res[, statistic := as.character(statistic)]

# Add Method_Performance column
anova_res[, Method_Performance := ifelse(
  directionality[[.BY[[1]]]] == TRUE,
  ifelse(mean_difference > 0, "Evaluated Method Better", "EMU Better"),
  ifelse(mean_difference < 0, "Evaluated Method Better", "EMU Better")
), by = statistic]

# Check the updated data
head(anova_res)


anova_res[,.N,by=Method_Performance]
```


```{r, fig.height=20, fig.width=18}
# View the results
print(anova_res[method == 'SpeciesEstimate'])

# Plot
ggp <- ggplot(anova_res[], 
       aes(x = method, y = mean_difference, fill = is.significant)) +
  geom_point(aes(size=p_value), shape=21) +
  #facet_wrap(~statistic + Detection_threshold_ratio + rank, scales = 'free_y', ncol=10) +
  facet_nested(cols=vars(Detection_threshold_ratio), rows=vars(statistic), scales = 'free_y') +
  theme_ipsum() +
  theme(legend.position = 'bottom') +
  labs(title = 'Comparison of Methods for Every Statistic at Species Rank',
       x = 'Method',
       y = 'R2 Value')

ggp
```


```{r, fig.height=20, fig.width=18}
# Plot
ggp <- ggplot(anova_res[], 
       aes(x = method, y = p_value, fill = is.significant)) +
  geom_point(size=3, shape=21) +
  geom_hline(yintercept = 0.05) +
  #facet_wrap(~statistic + Detection_threshold_ratio + rank, scales = 'free_y', ncol=10) +
  facet_nested(cols=vars(Detection_threshold_ratio), rows=vars(statistic), scales = 'free_y') +
  theme_ipsum() +
  theme(legend.position = 'bottom') +
  labs(title = 'Comparison of Methods for Every Statistic at Species Rank',
       x = 'Method',
       y = 'R2 Value')

ggp

```



## Compare the primer sets


```{r}

# Define the function
compare_primers <- function(data, method_to_use) {
  # Ensure data is a data.table
  if (!is.data.table(data)) {
    data <- as.data.table(data)
  }
  
  # List of primers to compare
  primers_list <- unique(data$primer)
  
  # Get unique statistics
  statistics_list <- unique(data$statistic)
  
  # Initialize a list to store results
  results_list <- list()
  
  # Generate all unique pairs of primers
  primer_pairs <- combn(primers_list, 2, simplify = FALSE)
  
  # Loop over each statistic
  for (stat in statistics_list) {
    # Filter data for the current statistic and method
    data_stat <- data[statistic == stat & method == method_to_use]
    
    # Loop over each primer pair
    for (pair in primer_pairs) {
      primer1 <- pair[1]
      primer2 <- pair[2]
      
      # Check if both primers are present in the data for this statistic and method
      if (all(c(primer1, primer2) %in% data_stat$primer)) {
        result_entry <- NULL
        
        try({
          # Filter data for the two primers
          data_filtered <- data_stat[primer %in% c(primer1, primer2)]
          
          # Reshape data to wide format
          data_wide <- dcast(data_filtered, 
                             sample_nr + rank ~ primer, 
                             value.var = 'value')
          
          # Ensure there are no missing values
          data_wide <- na.omit(data_wide)
          
          # Calculate the difference between the two primers
          data_wide[, diff := get(primer1) - get(primer2)]
          
          # Check for normality of differences using Shapiro-Wilk test
          if (length(data_wide$diff) >= 3) {  # Shapiro-Wilk requires at least 3 observations
            shapiro_test <- shapiro.test(data_wide$diff)
            normality <- ifelse(shapiro_test$p.value > 0.05, TRUE, FALSE)
          } else {
            shapiro_test <- list(p.value = NA)
            normality <- FALSE  # Default to non-normal if not enough data
          }
          
          # Perform the appropriate paired test
          if (normality) {
            test_result <- t.test(data_wide[[primer1]], data_wide[[primer2]], paired = TRUE)
            test_used <- 'Paired t-test'
          } else {
            test_result <- wilcox.test(data_wide[[primer1]], data_wide[[primer2]], paired = TRUE)
            test_used <- 'Wilcoxon signed-rank test'
          }
          
          # Store the results
          result_entry <- data.table(
            statistic = stat,
            comparison = paste(primer1, 'vs', primer2),
            primer1 = primer1,
            primer2 = primer2,
            test = test_used,
            p_value = test_result$p.value,
            mean_difference = mean(data_wide$diff, na.rm = TRUE),
            normality = normality,
            shapiro_p = shapiro_test$p.value,
            sample_size = nrow(data_wide)
          )
        })
        
        # Append to results list
        results_list[[length(results_list) + 1]] <- result_entry
      } else {
        warning(paste('Primers not found in data for statistic:', stat, 'and primers:', primer1, 'and', primer2))
      }
    }
  }
  
  # Combine all results into a data.table
  results_dt <- rbindlist(results_list)
  return(results_dt)
}

```



```{r}
anova_res_spec <- data.table(NULL)
anova_res_gen <- data.table(NULL)
# Define the detection threshold ratios
detect.tresh.ratios <- c(1e-2, 1e-3, 1e-4)  # Adjust according to your data

# Loop for species level
for(detect.tresh.ratio in detect.tresh.ratios) {
  
  anova_detect <- all.stat.df[Detection_threshold_ratio == detect.tresh.ratio, 
                             .(statistic, value, sample, primer, sample_name, sample_nr, method, rank=level)]
  anova_r2     <- plot_sum   [,.(statistic='R2', value=R2, sample, primer, sample_name, sample_nr, method, rank)]
  
  anova_stats  <- rbind(anova_r2, anova_detect)
  
  anova_stats  <- anova_stats[rank == 'species' & method == 'SpeciesEstimate']
  
  # Use only the 'SpeciesEstimate' method
  stat_res_spec <- compare_primers(anova_stats, method_to_use = 'SpeciesEstimate')  
  stat_res_spec[, Detection_threshold_ratio := detect.tresh.ratio]
  
  anova_res_spec <- rbind(anova_res_spec, stat_res_spec)
}

anova_res_spec[, rank := 'species']

# Loop for genus level
for(detect.tresh.ratio in detect.tresh.ratios) {
  
  anova_detect <- all.stat.df[Detection_threshold_ratio == detect.tresh.ratio, 
                             .(statistic, value, sample, primer, sample_name, sample_nr, method, rank=level)]
  anova_r2     <- plot_sum   [,.(statistic='R2', value=R2, sample, primer, sample_name, sample_nr, method, rank)]
  
  anova_stats  <- rbind(anova_r2, anova_detect)
  
  # Use only the 'SpeciesEstimate' method
  stat_res_gen <- compare_primers(anova_stats[rank == 'genus'], method_to_use = 'SpeciesEstimate')  
  stat_res_gen[, Detection_threshold_ratio := detect.tresh.ratio]
  
  anova_res_gen <- rbind(anova_res_gen, stat_res_gen)
}

anova_res_gen[, rank := 'genus']


anova_res <- rbind(anova_res_gen, anova_res_spec)

anova_res[, is.significant := fifelse(p_value <= 0.05, TRUE, FALSE)]

print(anova_res)
```


```{r, fig.height=12, fig.width=26}
# View the results
print(anova_res[])

# Plot
ggplot(anova_res[], 
       aes(x = comparison, y = mean_difference, fill = is.significant)) +
  geom_point(aes(size=p_value), shape=21) +
  facet_wrap(~statistic + Detection_threshold_ratio + rank, scales = 'free_y', ncol=10) +
  #facet_nested(cols=vars(Detection_threshold_ratio), rows=vars(statistic), scales = 'free_y') +
  theme_bw() +
  labs(title = 'Comparison of Methods for R2 Statistic at Species Rank',
       x = 'Method',
       y = 'R2 Value')

```



```{r}
save.image(paste0(res.dir, '.RData'))
```


